This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ‚ãÆ---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ‚ãÆ---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  ISSUE_TEMPLATE/
    bug_report.yml
    config.yml
    other.yml
    question.yml
    rfc.yml
  workflows/
    audit.yaml
    node.yaml
    publish-prerelease.yaml
    sonar.yaml
  dependabot.yml
  PULL_REQUEST_TEMPLATE.md
.husky/
  pre-commit
packages/
  connector/
    src/
      config/
        connectionConfig.ts
      connection/
        mosMessageParser.ts
        mosSocketClient.ts
        mosSocketServer.ts
        NCSServerConnection.ts
        Server.ts
        socketConnection.ts
      api.ts
      index.ts
      lib.ts
      MosConnection.ts
      MosDevice.ts
    .eslintrc.js
    .prettierignore
    jest.config.js
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
  examples/
    src/
      client.ts
      server.ts
    .eslintrc.js
    .prettierignore
    jest.config.js
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
  helper/
    src/
      mosModel/
        profile0/
          heartBeat.ts
          index.ts
          listMachInfo.ts
          reqMachInfo.ts
          xmlConversion.ts
        profile1/
          index.ts
          mosAck.ts
          mosListAll.ts
          mosObj.ts
          reqMosObj.ts
          reqMosObjAll.ts
          xmlConversion.ts
        profile2/
          index.ts
          ROAck.ts
          roActions.ts
          roCreate.ts
          roDelete.ts
          roElementStat.ts
          ROList.ts
          ROListAll.ts
          roMetadataReplace.ts
          roReadyToAir.ts
          roReplace.ts
          roReq.ts
          xmlConversion.ts
        profile3/
          index.ts
          mosItemReplace.ts
          mosListSearchableSchema.ts
          mosObjCreate.ts
          mosObjList.ts
          mosReqObjAction.ts
          mosReqObjList.ts
          mosReqSearchableSchema.ts
          xmlConversion.ts
        profile4/
          index.ts
          roReqAll.ts
          roStory.ts
          xmlConversion.ts
        index.ts
        lib.ts
        MosMessage.ts
        ParseError.ts
        parseMosTypes.ts
      stringify/
        stringifyMosObject.ts
      utils/
        ensureMethods.ts
        Errors.ts
        Utils.ts
      index.ts
    .eslintrc.js
    .prettierignore
    jest.config.js
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
  model/
    src/
      mosTypes/
        lib.ts
        mosDuration.ts
        mosString128.ts
        mosTime.ts
      index.ts
      model.ts
      mosTypes.ts
      xmlParse.ts
    .eslintrc.js
    .prettierignore
    jest.config.js
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
  mos-dummy-device/
    rundowns/
      defaultrundown.json
    src/
      index.ts
    package.json
    README.md
    tsconfig.json
  quick-mos/
    input/
      runningorders/
        .gitignore
        empty.ts
        README.md
      config.ts
      util.ts
    src/
      convertFromSofieSnapshot.ts
      index.ts
      mosDiff.ts
    .eslintrc.js
    jest.config.js
    LICENSE
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
scripts/
  fix-version.js
  reset.js
  update-packages.mjs
.editorconfig
.eslintrc.js
.gitattributes
.gitignore
.prettierignore
.repomixignore
.yarnrc.yml
commonPackage.json
CONTRIBUTING.md
jest.config.base.js
lerna.json
LICENSE
package.json
README.md
sonar-project.properties
tsconfig.build.json
tsconfig.json

================================================================
Files
================================================================

================
File: .github/ISSUE_TEMPLATE/bug_report.yml
================
name: Bug Report üêõ
description: Use this if you've found a bug
title: "Bug Report: [Short description of the bug]"
labels:
  - üêõbug

body:
  - type: markdown
    attributes:
      value: |
        Before you post, be sure to read our Contribution guidelines:
        https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines

  - type: textarea
    attributes:
      label: About me
      description: Tell us who / which organization you are representing, and how the Sofie team will be able to contact you.
      placeholder: Example "This RFC is posted on behalf of the NRK."
    validations:
      required: true

  - type: textarea
    attributes:
      label: Observed Behavior
      description: What happened?
    validations:
      required: true

  - type: textarea
    attributes:
      label: Expected Behavior
      description: What did you expect to happen?
    validations:
      required: true

  - type: input
    attributes:
      label: Version
      description: What version of Sofie Core / Gateways / other components are you using?
    validations:
      required: true

  - type: textarea
    attributes:
      label: Severity / Impact
      description: How big of an issue is this? How does this limit your operations?
      placeholder: |
        Examples:
        * This is a blocker for us, we cannot use feature X until this is fixed.
        * Not a big issue for us, but it would be nice to have this fixed.

================
File: .github/ISSUE_TEMPLATE/config.yml
================
blank_issues_enabled: false

================
File: .github/ISSUE_TEMPLATE/other.yml
================
name: Other Issue üîß
description: Use this for other issues
title: "Other: [Short description of the issue]"
labels:
  - Other

body:
  - type: markdown
    attributes:
      value: |
        Before you post, be sure to read our Contribution guidelines:
        https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines

  - type: textarea
    attributes:
      label: About me
      description: Tell us who / which organization you are representing, and how the Sofie team will be able to contact you.
      placeholder: Example "This RFC is posted on behalf of the NRK."
    validations:
      required: true

  - type: textarea
    attributes:
      label: Issue
      description: Describe the issue below
    validations:
      required: true

================
File: .github/ISSUE_TEMPLATE/question.yml
================
name: Question ‚ùì
description: Use this if you have a question to the Sofie team
title: "Question: [Short summary of the question]"
labels:
  - ‚ùì Question

body:
  - type: markdown
    attributes:
      value: |
        Before you post, be sure to read our Contribution guidelines:
        https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines

  - type: textarea
    attributes:
      label: About me
      description: Tell us who / which organization you are representing, and how the Sofie team will be able to contact you.
      placeholder: Example "This RFC is posted on behalf of the NRK."
    validations:
      required: true

  - type: textarea
    attributes:
      label: My Question
      description: Write your question below
    validations:
      required: true

================
File: .github/ISSUE_TEMPLATE/rfc.yml
================
name: Request for Comments ‚ùó
description: Use this to initiate a discussion about a new feature or a larger change
title: "RFC: [Short description of the feature/change]"
labels:
  - RFC
  - Contribution

body:
  - type: markdown
    attributes:
      value: |
        Before you post, be sure to read our Contribution guidelines:
        https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines

  - type: textarea
    attributes:
      label: About me
      description: Tell us who / which organization you are representing, and how the Sofie team will be able to contact you.
      placeholder: Example "This RFC is posted on behalf of the NRK."
    validations:
      required: true

  - type: textarea
    attributes:
      label: Use case
      description: "Please write some background information here, such as: What is your use case? What problem are you trying to solve?"
    validations:
      required: true

  - type: textarea
    attributes:
      label: Proposal
      description: Please describe your proposal here
    validations:
      required: true

  - type: textarea
    attributes:
      label: Process
      description: Please don't touch this section, the Sofie team will update this as the RFC progresses.
      value: |
        The Sofie Team will evaluate this RFC and open up a discussion about it, usually within a week.
        - [x] RFC created
        - [ ] Sofie Team has evaluated the RFC
        - [ ] A workshop has been planned
        - [ ] RFC has been discussed in a workshop
        - [ ] A conclusion has been reached, see comments in thread

================
File: .github/dependabot.yml
================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
    reviewers:
      - "@nrkno/sofie-ops"

================
File: .github/PULL_REQUEST_TEMPLATE.md
================
<!--
Before you open a PR, be sure to read our Contribution guidelines:
https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines
-->

## About the Contributor
<!--
Tell us who / which organization you are representing, and how the Sofie team will be able to contact you.
Example: "This pull request is posted on behalf of the NRK."
-->


## Type of Contribution

This is a: 
<!-- (pick one) -->
Bug fix / Feature / Code improvement / Documentation improvement / Other (please specify)


## Current Behavior
<!--
Please describe how things worked before this PR.
If it's a bug fixe: Describe the bug (what was happening?)
-->


## New Behavior
<!--
What is the new behavior?
-->


## Testing Instructions
<!--
Please provide some instructions and other information for how to verify that the feature works.
Examples:
* "Do a Take for a part that contains an adlib, verify that the adlib plays out."
* "Open the Switchboard panel and toggle a route, verify that the route toggles in the GUI."
* "This feature also affects 'feature X', so that needs to be tested for regressions as well."
-->


## Other Information
<!-- The more information you can provide, the easier the pull request will be to merge -->


## Status
<!--
Before you open the PR, make sure the items below are done.
If they're not, please open the PR as a Draft.
-->

- [ ] PR is ready to be reviewed.
- [ ] The functionality has been tested by the author.
- [ ] Relevant unit tests has been added / updated.
- [ ] Relevant documentation (code comments, [system documentation](https://nrkno.github.io/sofie-core/)) has been added / updated.

================
File: .husky/pre-commit
================
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

node scripts/update-packages.mjs

yarn run lint-staged

================
File: packages/connector/src/config/connectionConfig.ts
================
import { IProfiles } from '@mos-connection/model'
import { IConnectionConfig, IMOSDeviceConnectionOptions } from '../api'
‚ãÆ----
/** */
‚ãÆ----
export class ConnectionConfig implements IConnectionConfig
‚ãÆ----
// options for on-the-fly-created connections
‚ãÆ----
constructor(init: IConnectionConfig)
‚ãÆ----
/* tslint:disable */
‚ãÆ----
/* tslint:enable */
‚ãÆ----
/** */
get profiles(): IProfiles
‚ãÆ----
/** */
set profiles(profileSupport: IProfiles)
‚ãÆ----
// profile 0 is mandatory
‚ãÆ----
// Profile 1 depends on 0
‚ãÆ----
// Profile 2 depends on 0 and 1
‚ãÆ----
// Profile 3 depends on 0, 1 and 2
‚ãÆ----
// Profile 4 depends on 0, 1 and 2
‚ãÆ----
// Profile 5 depends on 0, 1 and 2
‚ãÆ----
// Profile 6 depends on 0, 1 and 2
‚ãÆ----
// Profile 7 depends on 0, 1 and 2
‚ãÆ----
// must support at least one other profile, other than Profile 0
‚ãÆ----
// machineInfo: {
// 	manufacturer: "SuperFly.tv",
//     model: 	"YAAS"
//     //hwRev:	 ,
//     swRev: 	'0.0.1.0'
//     DOM: 	'', // date of manufacture
//     /*<SN>927748927</SN>
//     <ID>airchache.newscenter.com</ID>
//     <time>2009-04-11T17:20:42</time>
//     <opTime>2009-03-01T23:55:10</opTime>
//     <mosRev>2.8.2</mosRev>
//     */
// }

================
File: packages/connector/src/connection/Server.ts
================
import { Socket } from 'net'
import { ConnectionType, SocketDescription } from './socketConnection'
‚ãÆ----
/** */
export class Server
‚ãÆ----
// private _connected: boolean
// private _lastSeen: number
‚ãÆ----
/** */
registerIncomingConnection(socketID: number, socket: Socket, portDescription: ConnectionType): void
‚ãÆ----
/** */
removeSocket(socketID: number): void
‚ãÆ----
private _getSockets(portDescription: string): Socket[]
/** */
get lowerPortSockets(): Socket[]
‚ãÆ----
/** */
get upperPortSockets(): Socket[]
‚ãÆ----
/** */
get queryPortSockets(): Socket[]

================
File: packages/connector/src/connection/socketConnection.ts
================
import { Socket } from 'net'
‚ãÆ----
/** */
export enum SocketConnectionEvent {
	CONNECTED = 'eventsocketconnectionconnected',
	DISCONNECTED = 'eventsocketconnectiondisconnected',
	DISPOSED = 'eventsocketconnectiondisposed',
	TIMEOUT = 'eventsocketconnectiontimeout',
	ALIVE = 'eventsocketconnectionalive',
	REGISTER = 'eventsocketconnectionregister',
	UNREGISTER = 'eventsocketconnectionunregister',
}
‚ãÆ----
/** */
export enum SocketServerEvent {
	// LISTENING = 'eventsocketserverlistening',
	// DISPOSED = 'eventsocketserverdisposed',
	// ALIVE = 'eventsocketserveralive',
	CLIENT_CONNECTED = 'eventsocketserverclientconnected',
	ERROR = 'eventsocketserverclienterror',
	CLOSE = 'eventsocketserverclientclose',
}
‚ãÆ----
// LISTENING = 'eventsocketserverlistening',
// DISPOSED = 'eventsocketserverdisposed',
// ALIVE = 'eventsocketserveralive',
‚ãÆ----
/** */
export type ConnectionType = IncomingConnectionType | OutgoingConnectionType
export type IncomingConnectionType = 'lower' | 'upper' | 'query'
export type OutgoingConnectionType = 'lower' | 'upper'
‚ãÆ----
/** */
export type SocketDescription = {
	socket: Socket
	portDescription: ConnectionType
}

================
File: packages/connector/src/lib.ts
================
/** Return true if the object has a property */
export function has(obj: unknown, property: string): boolean
export function safeStringify(obj: unknown): string
‚ãÆ----
export function isTestingWithJest(): boolean
‚ãÆ----
// If running in Jest, wait a bit longer before checking the profile validity:

================
File: packages/connector/.eslintrc.js
================


================
File: packages/connector/.prettierignore
================
package.json

================
File: packages/connector/jest.config.js
================


================
File: packages/connector/README.md
================
# @mos-connection/connector

This is the **connector** of the [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

It is a Node.js library used to connect to MOS services.

Read the full documentation at the main repo [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

================
File: packages/connector/tsconfig.build.json
================
{
    "extends": "../../tsconfig.build.json",
    "include": [
        "src/**/*.ts"
    ],
    "compilerOptions": {
        "outDir": "./dist",
    }
}

================
File: packages/connector/tsconfig.json
================
{
    "extends": "../../tsconfig.json",
    "include": [
        "src/**/*.ts"
    ]
}

================
File: packages/examples/src/client.ts
================
import {
	MosConnection,
	ConnectionConfig,
	IMOSROAck,
	IMOSROAction,
	IMOSROReadyToAir,
	IMOSROStory,
	IMOSRunningOrder,
	IMOSStoryAction,
	MosDevice,
	IMOSString128,
} from '@mos-connection/connector'
‚ãÆ----
// mos.on('rawMessage', (_source, _type, _message) => {
// 	console.log('rawMessage', _source, _type, _message)
// })
‚ãÆ----
// console.log(dev)
‚ãÆ----
const mosTypes = mosDevice.mosTypes // Could also be retrieved with getMosTypes(strict)
‚ãÆ----
const sendInit = async () =>
‚ãÆ----
// trigger a re-send of those running orders:
// return dev.getRunningOrder(mosTypes.mosString128.create('696297DF-1568-4B36-B43B3B79514B40D4'))
‚ãÆ----
// opTime?: mosTypes.mosTime.create(),
‚ãÆ----
// To connect to a server on custom ports:
// ports: {
// 	lower: 11540,
// 	upper: 11541,
// 	query: 11542,
// },

================
File: packages/examples/src/server.ts
================
import { MosConnection, ConnectionConfig } from '@mos-connection/connector'
‚ãÆ----
// To start the server on custom ports:
// ports: {
// 	lower: 11540,
// 	upper: 11541,
// 	query: 11542,
// },
‚ãÆ----
const mosTypes = mosDevice.mosTypes // Could also be retrieved with getMosTypes(strict)
‚ãÆ----
// opTime?: mosTypes.mosTime.create(),

================
File: packages/examples/.eslintrc.js
================


================
File: packages/examples/.prettierignore
================
package.json

================
File: packages/examples/jest.config.js
================


================
File: packages/examples/README.md
================
# @mos-connection/connector

This is the **connector** of the [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

It is a Node.js library used to connect to MOS services.

Read the full documentation at the main repo [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

================
File: packages/examples/tsconfig.build.json
================
{
    "extends": "../../tsconfig.build.json",
    "include": [
        "src/**/*.ts"
    ],
    "compilerOptions": {
        "outDir": "./dist",
    }
}

================
File: packages/examples/tsconfig.json
================
{
    "extends": "../../tsconfig.json",
    "include": [
        "src/**/*.ts"
    ]
}

================
File: packages/helper/src/mosModel/profile0/index.ts
================


================
File: packages/helper/src/mosModel/profile0/listMachInfo.ts
================
import { IMOSListMachInfo } from '@mos-connection/model'
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { XMLMosListMachInfo } from './xmlConversion'
‚ãÆ----
export class ListMachineInfo extends MosMessage
‚ãÆ----
/** */
constructor(info: IMOSListMachInfo, port: 'upper' | 'lower', strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile0/reqMachInfo.ts
================
import { MosMessage } from '../MosMessage'
‚ãÆ----
export class ReqMachInfo extends MosMessage
‚ãÆ----
/** */
constructor(strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile1/index.ts
================


================
File: packages/helper/src/mosModel/profile1/mosAck.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSAck, IMOSAckStatus, IMOSString128 } from '@mos-connection/model'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class MOSAck extends MosMessage implements IMOSAck
‚ãÆ----
Revision: number // max 999
‚ãÆ----
/** */
constructor(ack: IMOSAck, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile1/mosListAll.ts
================
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { IMOSObject } from '@mos-connection/model'
import { XMLMosObject } from '../profile1/xmlConversion'
‚ãÆ----
export class MosListAll extends MosMessage
‚ãÆ----
/** */
constructor(objs: Array<IMOSObject>, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile1/mosObj.ts
================
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { IMOSObject } from '@mos-connection/model'
import { XMLMosObject } from './xmlConversion'
‚ãÆ----
export class MosObj extends MosMessage
‚ãÆ----
/** */
constructor(obj: IMOSObject, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile1/reqMosObj.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSString128 } from '@mos-connection/model'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class ReqMosObj extends MosMessage
‚ãÆ----
/** */
constructor(objId: IMOSString128, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile2/index.ts
================


================
File: packages/helper/src/mosModel/profile2/ROAck.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSROAck, IMOSROAckStory, IMOSString128 } from '@mos-connection/model'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class ROAck extends MosMessage implements IMOSROAck
‚ãÆ----
/** */
constructor(roAck: IMOSROAck, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement
‚ãÆ----
// Loop over Stories, Items and Object

================
File: packages/helper/src/mosModel/profile2/roActions.ts
================
import { MosMessage } from '../MosMessage'
import {
	IMOSStoryAction,
	IMOSROStory,
	IMOSItemAction,
	IMOSItem,
	IMOSROAction,
	IMOSString128,
} from '@mos-connection/model'
import { XMLROStory, XMLMosItem } from './xmlConversion'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export abstract class MosSendMessage extends MosMessage
‚ãÆ----
constructor(strict: boolean)
‚ãÆ----
export class ROInsertStories extends MosSendMessage
‚ãÆ----
constructor(private Action: IMOSStoryAction, private Stories: Array<IMOSROStory>, strict: boolean)
get messageXMLBlocks(): XMLBuilder.XMLElement
‚ãÆ----
export class ROInsertItems extends MosSendMessage
‚ãÆ----
constructor(private Action: IMOSItemAction, private Items: Array<IMOSItem>, strict: boolean)
‚ãÆ----
export class ROReplaceStories extends MosSendMessage
export class ROReplaceItems extends MosSendMessage
export class ROMoveStories extends MosSendMessage
‚ãÆ----
constructor(private Action: IMOSStoryAction, private Stories: Array<IMOSString128>, strict: boolean)
‚ãÆ----
export class ROMoveItems extends MosSendMessage
‚ãÆ----
constructor(private Action: IMOSItemAction, private Items: Array<IMOSString128>, strict: boolean)
‚ãÆ----
export class RODeleteStories extends MosSendMessage
‚ãÆ----
constructor(private Action: IMOSROAction, private Stories: Array<IMOSString128>, strict: boolean)
‚ãÆ----
export class RODeleteItems extends MosSendMessage
‚ãÆ----
constructor(private Action: IMOSStoryAction, private Items: Array<IMOSString128>, strict: boolean)
‚ãÆ----
export class ROSwapStories extends MosSendMessage
‚ãÆ----
constructor(
		private Action: IMOSROAction,
		private StoryID0: IMOSString128,
		private StoryID1: IMOSString128,
		strict: boolean
)
‚ãÆ----
export class ROSwapItems extends MosSendMessage
‚ãÆ----
constructor(
		private Action: IMOSStoryAction,
		private ItemID0: IMOSString128,
		private ItemID1: IMOSString128,
		strict: boolean
)

================
File: packages/helper/src/mosModel/profile2/roCreate.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSRunningOrder } from '@mos-connection/model'
import { XMLROStory, XMLRunningOrderBase } from './xmlConversion'
‚ãÆ----
export class ROCreate extends MosMessage
‚ãÆ----
/** */
constructor(private ro: IMOSRunningOrder, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement
protected fillXMLWithROData(root: XMLBuilder.XMLElement): void

================
File: packages/helper/src/mosModel/profile2/roDelete.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSString128 } from '@mos-connection/model'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class RODelete extends MosMessage
‚ãÆ----
constructor(private roId: IMOSString128, strict: boolean)
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile2/ROList.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSRunningOrder } from '@mos-connection/model'
import { XMLROStory, XMLRunningOrderBase } from './xmlConversion'
‚ãÆ----
export class ROList extends MosMessage
‚ãÆ----
/** */
constructor(private ro: IMOSRunningOrder, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement
‚ãÆ----
protected fillXMLWithROData(root: XMLBuilder.XMLElement): void

================
File: packages/helper/src/mosModel/profile2/roMetadataReplace.ts
================
import { IMOSRunningOrderBase } from '@mos-connection/model'
import { MosMessage } from '../MosMessage'
import { XMLRunningOrderBase } from './xmlConversion'
‚ãÆ----
export class ROMetadataReplace extends MosMessage
‚ãÆ----
constructor(private metadata: IMOSRunningOrderBase, strict: boolean)
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile2/roReadyToAir.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSString128 } from '@mos-connection/model'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
// https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReadyToAir
‚ãÆ----
export interface ROReadyToAirOptions {
	roId: IMOSString128
	roAir: 'READY' | 'NOT READY'
}
export class ROReadyToAir extends MosMessage
‚ãÆ----
constructor(options: ROReadyToAirOptions, strict: boolean)
‚ãÆ----
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile2/roReplace.ts
================
import { IMOSRunningOrder } from '@mos-connection/model'
import { ROCreate } from './roCreate'
‚ãÆ----
export class ROReplace extends ROCreate
‚ãÆ----
constructor(ro: IMOSRunningOrder, strict: boolean)
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile2/roReq.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSString128 } from '@mos-connection/model'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class ROReq extends MosMessage
‚ãÆ----
/** */
constructor(roId: IMOSString128, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile3/mosItemReplace.ts
================
import { MosItemReplaceOptions } from '@mos-connection/model'
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { XMLMosItem } from '../profile2/xmlConversion'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class MosItemReplace extends MosMessage
‚ãÆ----
constructor(options: MosItemReplaceOptions, strict: boolean)
‚ãÆ----
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile3/mosObjCreate.ts
================
import { IMOSObject } from '@mos-connection/model'
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { XMLMosObject } from '../profile1/xmlConversion'
‚ãÆ----
// https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObjCreate
export class MosObjCreate extends MosMessage
‚ãÆ----
constructor(object: IMOSObject, strict: boolean)
‚ãÆ----
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile3/mosObjList.ts
================
import { IMOSObjectList } from '@mos-connection/model'
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { XMLMosObjects } from '../profile1/xmlConversion'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class MosObjList extends MosMessage
‚ãÆ----
constructor(options: IMOSObjectList, strict: boolean)
‚ãÆ----
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile3/mosReqObjAction.ts
================
import { IMOSObject, IMOSString128 } from '@mos-connection/model'
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { XMLMosObject } from '../profile1/xmlConversion'
export interface MosReqObjActionOptionsNew {
	object: IMOSObject
}
export class MosReqObjActionNew extends MosMessage
‚ãÆ----
constructor(options: MosReqObjActionOptionsNew, strict: boolean)
get messageXMLBlocks(): XMLBuilder.XMLElement
‚ãÆ----
export interface MosReqObjActionOptionsUpdate {
	object: IMOSObject
	objectId: IMOSString128
}
export class MosReqObjActionUpdate extends MosMessage
‚ãÆ----
constructor(options: MosReqObjActionOptionsUpdate, strict: boolean)
‚ãÆ----
export interface MosReqObjActionOptionsDelete {
	objectId: IMOSString128
}
export class MosReqObjActionDelete extends MosMessage
‚ãÆ----
constructor(options: MosReqObjActionOptionsDelete, strict: boolean)

================
File: packages/helper/src/mosModel/profile3/mosReqSearchableSchema.ts
================
import { MosMessage } from '../MosMessage'
‚ãÆ----
export class MosReqSearchableSchema extends MosMessage
‚ãÆ----
constructor(options:
‚ãÆ----
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile4/index.ts
================


================
File: packages/helper/src/mosModel/profile4/roReqAll.ts
================
import { MosMessage } from '../MosMessage'
‚ãÆ----
export class ROReqAll extends MosMessage
‚ãÆ----
/** */
constructor(strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/.eslintrc.js
================


================
File: packages/helper/.prettierignore
================
package.json

================
File: packages/helper/jest.config.js
================


================
File: packages/helper/README.md
================
# @mos-connection/helper

This is the **helper** of the [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

It is a library that provides various functions useful for those that prepare/handle data that will be sent to (or has been received by) the [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

Read the full documentation at the main repo [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

================
File: packages/helper/tsconfig.build.json
================
{
    "extends": "../../tsconfig.build.json",
    "include": [
        "src/**/*.ts"
    ],
    "compilerOptions": {
        "outDir": "./dist",
    }
}

================
File: packages/helper/tsconfig.json
================
{
    "extends": "../../tsconfig.json",
    "include": [
        "src/**/*.ts"
    ]
}

================
File: packages/model/.eslintrc.js
================


================
File: packages/model/.prettierignore
================
package.json

================
File: packages/model/jest.config.js
================


================
File: packages/model/README.md
================
# @mos-connection/model

This is the **model** of the [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

It is a library that contains types and enums, useful for applications that handles MOS-data.

Read the full documentation at the main repo [MOS-connection](https://github.com/nrkno/sofie-mos-connection).

================
File: packages/model/tsconfig.build.json
================
{
    "extends": "../../tsconfig.build.json",
    "include": [
        "src/**/*.ts"
    ],
    "compilerOptions": {
        "outDir": "./dist",
    }
}

================
File: packages/model/tsconfig.json
================
{
    "extends": "../../tsconfig.json",
    "include": [
        "src/**/*.ts"
    ]
}

================
File: packages/mos-dummy-device/rundowns/defaultrundown.json
================
{
    "ID": "EXAMPLE_RO",
    "Slug": "Example Rundown",
    "DefaultChannel": "A",
    "Stories": [
      {
        "ID": "EXAMPLE_RO_STORY_1",
        "Slug": "Opening Story",
        "Number": "1",
        "Items": [
          {
            "ID": "EXAMPLE_RO_STORY_1_ITEM_1",
            "Slug": "Intro Graphic",
            "ObjectID": "OBJ_INTRO_GRAPHIC",
            "MOSID": "DUMMY.MOS.SERVER",
            "ObjectSlug": "Opening Title Graphic",
            "Duration": 500,
            "TimeBase": 100
          },
          {
            "ID": "EXAMPLE_RO_STORY_1_ITEM_2",
            "Slug": "Presenter Introduction",
            "ObjectID": "OBJ_PRESENTER_CAM1",
            "MOSID": "DUMMY.MOS.SERVER",
            "ObjectSlug": "Camera 1 - Wide",
            "Duration": 1000,
            "TimeBase": 100
          }
        ]
      },
      {
        "ID": "EXAMPLE_RO_STORY_2",
        "Slug": "News Story",
        "Number": "2",
        "Items": [
          {
            "ID": "EXAMPLE_RO_STORY_2_ITEM_1",
            "Slug": "News Intro",
            "ObjectID": "OBJ_NEWS_GRAPHIC",
            "MOSID": "DUMMY.MOS.SERVER",
            "ObjectSlug": "News Title Card",
            "Duration": 300,
            "TimeBase": 100
          },
          {
            "ID": "EXAMPLE_RO_STORY_2_ITEM_2",
            "Slug": "News Package",
            "ObjectID": "OBJ_NEWS_PKG_1",
            "MOSID": "DUMMY.MOS.SERVER",
            "ObjectSlug": "News Package Video",
            "Duration": 3000,
            "TimeBase": 100
          }
        ]
      },
      {
        "ID": "EXAMPLE_RO_STORY_3",
        "Slug": "Closing Story",
        "Number": "3",
        "Items": [
          {
            "ID": "EXAMPLE_RO_STORY_3_ITEM_1",
            "Slug": "Closing Remarks",
            "ObjectID": "OBJ_PRESENTER_CAM2",
            "MOSID": "DUMMY.MOS.SERVER",
            "ObjectSlug": "Camera 2 - Close Up",
            "Duration": 1500,
            "TimeBase": 100
          },
          {
            "ID": "EXAMPLE_RO_STORY_3_ITEM_2",
            "Slug": "Outro Graphic",
            "ObjectID": "OBJ_OUTRO_GRAPHIC",
            "MOSID": "DUMMY.MOS.SERVER",
            "ObjectSlug": "Closing Credits",
            "Duration": 800,
            "TimeBase": 100
          }
        ]
      }
    ]
  }

================
File: packages/mos-dummy-device/src/index.ts
================
/* eslint-disable node/no-unpublished-import */
import { MosConnection, ConnectionConfig, getMosTypes, IMOSRunningOrder, MosDevice } from '@mos-connection/connector'
‚ãÆ----
// Define the server configuration
‚ãÆ----
'0': true, // Profile 0 is mandatory
'1': true, // Basic object exchange
'2': true, // Running order/playlist exchange
'3': true, // Advanced object-based workflow
'4': true, // Advanced rundown functionality
‚ãÆ----
lower: 10540, // Default MOS ports, can be customized
‚ãÆ----
// Enable relay mode to create new MOS devices on-the-fly when receiving messages
‚ãÆ----
// Class for the dummy MOS server
class DummyMosServer
‚ãÆ----
private mosTypes = getMosTypes(false) // Non-strict mode
‚ãÆ----
constructor(rundownsDir: string)
‚ãÆ----
// Create the MOS connection
‚ãÆ----
// Set up device connection callback
‚ãÆ----
// Watch the rundowns directory for changes
‚ãÆ----
// Load any existing rundowns
‚ãÆ----
// Initialize and start the server
public async start(): Promise<void>
‚ãÆ----
// Handle new MOS device connections
private handleNewConnection(mosDevice: MosDevice): void
‚ãÆ----
// Store reference to the device
‚ãÆ----
// Set up callbacks for Profile 0
‚ãÆ----
// Set up callbacks for Profile 2
‚ãÆ----
// Set up Profile 4 callbacks
‚ãÆ----
// Send all rundowns to the device on connection
‚ãÆ----
// Load all rundowns from the rundowns directory
private loadRundowns(): void
‚ãÆ----
// Ensure ID is set correctly
‚ãÆ----
// Process and validate rundown (convert strings to MOS types)
‚ãÆ----
// Add to rundowns map
‚ãÆ----
// Watch the rundowns directory for changes
private setupRundownWatcher(): void
‚ãÆ----
// Handle new rundown file
private handleRundownFileAdded(filePath: string): void
‚ãÆ----
// Ensure ID is set correctly
‚ãÆ----
// Process and validate rundown
‚ãÆ----
// Add to rundowns map
‚ãÆ----
// Send to all connected devices
‚ãÆ----
// Handle rundown file changes
private handleRundownFileChanged(filePath: string): void
‚ãÆ----
// Process and validate rundown
‚ãÆ----
// Update in rundowns map
‚ãÆ----
// Send to all connected devices
‚ãÆ----
// Handle rundown file removals
private handleRundownFileRemoved(filePath: string): void
‚ãÆ----
// Remove from rundowns map
‚ãÆ----
// Notify all connected devices
‚ãÆ----
// Process a rundown to ensure all required MOS types are properly formatted
private processRundown(rundown: IMOSRunningOrder): IMOSRunningOrder
‚ãÆ----
// Deep copy to avoid modifying the original
‚ãÆ----
// Convert string values to MOS types
‚ãÆ----
// Process each story
‚ãÆ----
// Process items in each story
‚ãÆ----
// Send a running order to all connected devices
private broadcastRunningOrder(rundown: IMOSRunningOrder, isUpdate = false): void
‚ãÆ----
// Notify all connected devices about a deleted running order
private broadcastRunningOrderDelete(roId: string): void
‚ãÆ----
// Send all loaded rundowns to a newly connected device
private sendAllRunningOrders(device: MosDevice): void
‚ãÆ----
// Simulate a server outage
public simulateOutage(durationMs: number = 5000): void
‚ãÆ----
// Shutdown the server
public async shutdown(): Promise<void>
‚ãÆ----
// Main function
async function main()
‚ãÆ----
// Create and start the MOS server
‚ãÆ----
// Handle process termination
‚ãÆ----
// Command line interface for manual testing
‚ãÆ----
// Simple command processing
‚ãÆ----
// Run the application

================
File: packages/mos-dummy-device/package.json
================
{
    "name": "mos-dummy-server",
    "version": "1.0.0",
    "description": "A dummy MOS server for testing MOS clients with failover capabilities",
    "main": "dist/index.js",
    "scripts": {
        "build": "tsc",
        "start": "node dist/index.js",
        "dev": "ts-node src/index.ts",
        "watch": "nodemon --watch src -e ts --exec ts-node src/index.ts"
    },
    "keywords": [
        "mos",
        "broadcast",
        "testing",
        "dummy",
        "failover"
    ],
    "author": "",
    "license": "MIT",
    "dependencies": {
        "@mos-connection/connector": "^4.2.2",
        "chokidar": "^3.5.3"
    },
    "devDependencies": {
        "@types/node": "^20.10.5",
        "nodemon": "^3.0.2",
        "ts-node": "^10.9.2",
        "typescript": "^5.3.3"
    }
}

================
File: packages/mos-dummy-device/README.md
================
# MOS Dummy Server

A dummy MOS (Media Object Server) server for testing MOS clients with failover capabilities. This server implements the MOS protocol and allows you to simulate connection issues and manage rundowns through JSON files.

## Features

- Full MOS protocol support (Profiles 0, 1, 2, 3, and 4)
- JSON-based rundown management
- Hot reloading of rundowns from the filesystem
- Simulation of server outages for failover testing
- Command-line interface for manual testing

## Installation

1. Clone this repository
2. Install dependencies:

```bash
npm install
```

3. Build the project:

```bash
npm run build
```

## Usage

### Starting the server

```bash
npm start
```

This will start the MOS server on the default ports (10540, 10541, 10542).

### Development mode

To run in development mode with automatic reloading:

```bash
npm run dev
```

Or with file watching:

```bash
npm run watch
```

### Rundown Management

Rundowns are stored as JSON files in the `rundowns` directory. The server watches this directory for changes:

- Adding a new `.json` file creates a new rundown
- Modifying a file updates the rundown
- Deleting a file removes the rundown

### Rundown JSON Format

Here's an example of a rundown JSON file:

```json
{
  "ID": "EXAMPLE_RO",
  "Slug": "Example Rundown",
  "DefaultChannel": "A",
  "Stories": [
    {
      "ID": "EXAMPLE_RO_STORY_1",
      "Slug": "Story 1",
      "Number": "1",
      "Items": [
        {
          "ID": "EXAMPLE_RO_STORY_1_ITEM_1",
          "Slug": "Item 1 in Story 1",
          "ObjectID": "OBJ_EXAMPLE_RO_STORY_1_ITEM_1",
          "MOSID": "DUMMY.MOS.SERVER",
          "ObjectSlug": "Item 1 in Story 1",
          "Duration": 1000,
          "TimeBase": 100
        }
      ]
    }
  ]
}
```

### Command-Line Interface

While the server is running, you can use the following commands:

- `outage [duration_ms]` - Simulate a server outage for the specified duration (default: 5000ms)
- `create [id] [title] [story_count]` - Create an example rundown
- `exit` - Shutdown the server and exit

Example: `outage 10000` will simulate a 10-second outage.

## Configuration

You can modify the configuration in the `SERVER_CONFIG` object in `src/index.ts`:

- `mosID`: The MOS ID of the server
- `acceptsConnections`: Whether to accept incoming connections
- `profiles`: The MOS profiles to support
- `debug`: Enable/disable debug logging
- `ports`: The ports to use for MOS communication

## Testing Failover

To test failover with your MOS client:

1. Start the server
2. Connect your MOS client to the server
3. Use the `outage` command to simulate an outage
4. Observe how your client handles the disconnection and reconnection

================
File: packages/mos-dummy-device/tsconfig.json
================
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "lib": ["es2020"],
      "declaration": true,
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "resolveJsonModule": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "**/*.spec.ts"]
  }

================
File: packages/quick-mos/input/runningorders/.gitignore
================
*.ts
*.json

!empty.ts

================
File: packages/quick-mos/input/runningorders/empty.ts
================
import { IMOSScope } from '@mos-connection/model'
‚ãÆ----
// DefaultChannel?: ''
// EditorialStart?: MosTime;
// EditorialDuration?: MosDuration;
// Trigger?: ''
// MacroIn?: ''
// MacroOut?: ''

================
File: packages/quick-mos/src/mosDiff.ts
================
export interface ListEntry<T> {
	/** ID that uniquely identifies this entry */
	id: string
	/** Hash or timestamp, that changes whenever the content has changed */
	changedHash: string
	content: T
}
‚ãÆ----
/** ID that uniquely identifies this entry */
‚ãÆ----
/** Hash or timestamp, that changes whenever the content has changed */
‚ãÆ----
export type Operation<T> = OperationInsert<T> | OperationUpdate<T> | OperationRemove | OperationMove
export interface OperationBase {
	type: OperationType
}
export enum OperationType {
	INSERT = 'insert',
	UPDATE = 'update',
	REMOVE = 'remove',
	MOVE = 'move',
}
export interface OperationInsert<T> {
	type: OperationType.INSERT
	beforeId: string
	inserts: {
		id: string
		changedHash: string
		content: T
	}[]
}
export interface OperationUpdate<T> {
	type: OperationType.UPDATE
	id: string
	changedHash: string
	content: T
}
export interface OperationRemove {
	type: OperationType.REMOVE
	ids: string[]
}
export interface OperationMove {
	type: OperationType.MOVE
	ids: string[]
	beforeId: string
}
/** Takes an old and a new list, and returns the operations needed to synk the two */
export function diffLists<T>(oldList: ListEntry<T>[], newList: ListEntry<T>[]): Operation<T>[]
‚ãÆ----
// Preparations:
‚ãÆ----
// Find Inserted and Updated:
‚ãÆ----
// Find removed:
‚ãÆ----
// Apply Inserts, updates & removes on intermediary list:
/** Intermediate list. Start with the old order and gradually ends up in the ending order,
	 * as move operations are determined
	 */
‚ãÆ----
// Find Moved:
‚ãÆ----
const getInterPrevId = (id: string): string =>
‚ãÆ----
// const prevEntry: ListEntry<T> | undefined = newList[i - 1]
‚ãÆ----
// const nextEntry: ListEntry<T> | undefined = newList[i + 1]
‚ãÆ----
// The new entry is not following after the same element as the one that was before the beginning of the move operation
‚ãÆ----
// The new entry is following the element that was before the move operation started.
‚ãÆ----
// Optimize: when the tail of the move-operation is in the original order, it can be replaced by another smaller move operation:
‚ãÆ----
// The previous id is in the original order, continue
‚ãÆ----
// Yes, we can replace a number of ids with another move operation.
‚ãÆ----
currentMoveOperation.ids.length = i // remove entries after i
‚ãÆ----
// Commit the move operation:
// currentMoveOperation.beforeId = nextId
‚ãÆ----
// The new entry is not following the same entry as the old does
‚ãÆ----
// No change
‚ãÆ----
// todo? Optimize: when the tail of the operation will be on the end anyway:
‚ãÆ----
export function applyOperations<T>(oldList: ListEntry<T>[], operations: Operation<T>[]): ListEntry<T>[]
‚ãÆ----
let newList: ListEntry<T>[] = oldList.slice() // clone
‚ãÆ----
// Apply Inserts, updates & removes on intermediary list:
‚ãÆ----
// insert last
‚ãÆ----
// move last:
‚ãÆ----
/** Find and extract entries from list, and return them */
function extractList<T>(list: T[], fcn: (value: T) => number): T[]
function makeDenseArray<T>(sparse: Array<T | undefined | null>): T[]

================
File: packages/quick-mos/.eslintrc.js
================


================
File: packages/quick-mos/jest.config.js
================


================
File: packages/quick-mos/LICENSE
================
MIT License

Copyright (c) 2020 Johan Nyman

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: packages/quick-mos/README.md
================
# Quick-MOS

An application for quick simulation of a MOS server/NCS.

## Usage

- `yarn start` to start the application

- The application will monitor the contents in the folder `/input` and send mos commands.
- Files and folders that begin with "\_" (underscore) will be ignored

- Note: quickmos and mos-gateway must be run on different machines (or docker containers) as they both try to bind to the same ports. This is a limitation in the current implementation of mos-connection

================
File: packages/quick-mos/tsconfig.build.json
================
{
  "extends": "../../tsconfig.build.json",
  "include": [
      "src/**/*.ts",
      "input/**/*.ts"
  ],
  "compilerOptions": {
      "outDir": "./dist",
  }
}

================
File: packages/quick-mos/tsconfig.json
================
{
  "extends": "../../tsconfig.json",
  "include": [
      "src/**/*.ts",
      "input/**/*.ts"
  ]
}

================
File: scripts/fix-version.js
================
/* eslint-disable no-console */
‚ãÆ----
// This script fixes a few things after a release version has been bumped
‚ãÆ----
async function run() {
await removeFile('packages/examples/CHANGELOG.md')
await fixPackageVersion('packages/examples/package.json')
‚ãÆ----
await removeFile('packages/quick-mos/CHANGELOG.md')
await fixPackageVersion('packages/quick-mos/package.json')
‚ãÆ----
await commit()
‚ãÆ----
async function fixPackageVersion(filePath) {
filePath = path.resolve(filePath)
const packageJsonStr = await fs.promises.readFile(filePath, 'utf8')
const packageJson = JSON.parse(packageJsonStr)
‚ãÆ----
await fs.promises.writeFile(filePath, JSON.stringify(packageJson, null, '\t') + '\n', 'utf8')
‚ãÆ----
async function removeFile(filePath) {
‚ãÆ----
await fs.promises.unlink(filePath)
‚ãÆ----
// File does not exist, do nothing
‚ãÆ----
async function commit() {
const latestGitCommit = cp.execSync('git log -1')
‚ãÆ----
// get last git commit message
const message = latestGitCommit.toString().split('\n')[4].trim()
// Check that the last commit message is a version bump
if (message.match(/v\d+\.\d+.\d+/)) {
‚ãÆ----
console.log('Amending last commit with changes...')
exec('git add .')
exec('git commit --amend --no-edit --no-verify')
‚ãÆ----
// Move tag:
exec(`git tag -d ${tag}`)
exec(`git tag ${tag}`)
‚ãÆ----
console.log('NOT committing changes!')
‚ãÆ----
function exec(cmd) {
console.log(cmd)
cp.execSync(cmd)
‚ãÆ----
run()
.then(() => console.log('Done'))
.catch(console.error)

================
File: scripts/reset.js
================
/* eslint-disable node/no-unpublished-require, node/no-extraneous-require */
‚ãÆ----
const glob = promisify(require('glob'))
const rimraf = promisify(require('rimraf'))
‚ãÆ----
/*
	Removing all /node_modules and /dist folders
*/
‚ãÆ----
const basePath = process.cwd()
‚ãÆ----
log('Gathering files to remove...')
‚ãÆ----
// Remove things that arent used, to reduce file size:
const searchForFolder = async (name) => {
‚ãÆ----
...(await glob(`${basePath}/${name}`)),
...(await glob(`${basePath}/*/${name}`)),
...(await glob(`${basePath}/*/*/${name}`)),
...(await glob(`${basePath}/*/*/*/${name}`)),
...(await glob(`${basePath}/*/*/*/*/${name}`)),
‚ãÆ----
...(await searchForFolder('node_modules')),
...(await searchForFolder('dist')),
...(await searchForFolder('deploy')),
‚ãÆ----
if (folder.match(resultingFolder)) {
‚ãÆ----
resultingFolders.push(folder)
‚ãÆ----
const rootNodeModules = await glob(`${basePath}/node_modules`)
if (rootNodeModules.length !== 1) throw new Error(`Wrong length of root node_modules (${rootNodeModule.length})`)
‚ãÆ----
log(`Removing ${resultingFolders.length} files...`)
‚ãÆ----
log(`Removing ${folder}`)
await rimraf(folder)
‚ãÆ----
// Finally, remove root node_modules
‚ãÆ----
log(`...done!`)
})().catch(log)
‚ãÆ----
function log(...args) {
// eslint-disable-next-line no-console
console.log(...args)

================
File: scripts/update-packages.mjs
================
// /* eslint-disable node/no-unpublished-require */
‚ãÆ----
const glob = promisify(globOrg)
‚ãÆ----
const rootPackageStr = await fs.readFile(path.join(path.dirname(fileURLToPath(import.meta.url)), '../package.json'))
const rootPackage = JSON.parse(rootPackageStr.toString())
‚ãÆ----
/*
    This script copies some common properties (from commonPackage.json)
    into package.json of each of the packages.
    */
‚ãÆ----
const extendPackageStr = await fs.readFile('commonPackage.json')
const extendPackage = JSON.parse(extendPackageStr)
delete extendPackage.description // don't copy this propery
‚ãÆ----
const packageJsons = await glob(`${workspaceDef}/package.json`)
‚ãÆ----
if (!packageJsonPath.match(/node_modules/)) {
const packageJsonStr = await fs.readFile(packageJsonPath)
const packageJson = JSON.parse(packageJsonStr)
‚ãÆ----
const newPackageJson = deepExtend({}, packageJson, extendPackage)
‚ãÆ----
if (!_.isEqual(newPackageJson, packageJson)) {
await fs.writeFile(packageJsonPath, JSON.stringify(newPackageJson, undefined, '\t') + '\n')
‚ãÆ----
console.error(`Error when processing ${packageJsonPath}`)
‚ãÆ----
console.log(`Updated package.json of ${count} packages`)
console.log(`You should commit these changes and run yarn install again.`)
process.exit(1)

================
File: .editorconfig
================
[*]
indent_style = tab

[*.{cs,js,ts,json}]
indent_size = 4

[*.{yml,yaml}]
indent_size = 2
indent_style = space

================
File: .eslintrc.js
================


================
File: .gitattributes
================
* text=auto eol=lf

================
File: .gitignore
================
node_modules
dist
test
src/**.js

/**/coverage
/docs
.nyc_output
*.log

wallaby.conf.js

.DS_Store
docs/
.vscode/settings.json

.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks

================
File: .prettierignore
================
package.json

================
File: .repomixignore
================
__tests__/
__mocks__/
dist/
yarn.lock
CHANGELOG.md

================
File: .yarnrc.yml
================
nodeLinker: node-modules

plugins:
  - path: .yarn/plugins/@yarnpkg/plugin-version.cjs
    spec: "@yarnpkg/plugin-version"
  - path: .yarn/plugins/@yarnpkg/plugin-interactive-tools.cjs
    spec: "@yarnpkg/plugin-interactive-tools"
  - path: .yarn/plugins/@yarnpkg/plugin-workspace-tools.cjs
    spec: "@yarnpkg/plugin-workspace-tools"

yarnPath: .yarn/releases/yarn-3.6.0.cjs

================
File: commonPackage.json
================
{
	"description": "The properties of this file are copied to all packages' package.json files by running `yarn postinstall`",
	"scripts": {
		"validate:dependencies": "yarn npm audit --environment production && yarn license-validate",
		"validate:dev-dependencies": "yarn npm audit ",
		"license-validate": "yarn sofie-licensecheck"
	},
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "*",
		"typescript": "~4.9.5"
	},
	"engines": {
		"node": ">=14.18.0"
	},
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"lint-staged": {
		"*.{css,json,md,scss}": [
			"run -T prettier"
		],
		"*.{ts,tsx,js,jsx}": [
			"run -T eslint"
		]
	},
	"files": [
		"/dist",
		"/CHANGELOG.md",
		"/README.md",
		"/LICENSE"
	]
}

================
File: CONTRIBUTING.md
================
# How to Contribute to this Repository

Before contributing to this specific repository, please read the [Contribution Guidelines](https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines) for the Sofie project.


## Branches
This repository uses the following branches:

* **_master_** is our main branch. We consider it stable and it is used in production.
* The **_develop_** branch is our in-development branch. When a release is ready, we decide to ‚Äúfreeze‚Äù that branch and merge it into **_master_** branch.

We encourage you to base your contributions on the latest **_develop_** branch. The [_Sofie Releases_](https://nrkno.github.io/sofie-core/releases) page collects the status and timeline of the releases.

================
File: jest.config.base.js
================
// globals: {
// 	'ts-jest': {
// 		tsconfig: 'tsconfig.json',
// 	},
// },
‚ãÆ----
// verbose: true,

================
File: LICENSE
================
MIT License (MIT)

Copyright (c) 2023 Norsk rikskringkasting AS (NRK)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: sonar-project.properties
================
sonar.projectKey=nrkno_tv-automation-mos-connection
sonar.organization=nrkno

# This is the name and version displayed in the SonarCloud UI.
#sonar.projectName=sofie-mos-connection
#sonar.projectVersion=1.0

# Path is relative to the sonar-project.properties file. Replace "\" by "/" on Windows.
#sonar.sources=.

# Encoding of the source code. Default is default system encoding
#sonar.sourceEncoding=UTF-8

================
File: tsconfig.build.json
================
{
	"extends": "@sofie-automation/code-standard-preset/ts/tsconfig.lib",
	"include": [
		"**/src/**/*.ts"
	],
	"exclude": [
		"**/node_modules/**",
		"**/*spec.ts",
		"**/__tests__",
		"**/__mocks__",
		"**/scratch/**"
	],
	"compilerOptions": {
		"outDir": "./dist",
		"baseUrl": "./",
		"paths": {
			"*": [
				"./node_modules/*"
			]
		},
		"types": [
			"node"
		]
	}
}

================
File: tsconfig.json
================
{
	"extends": "./tsconfig.build.json",
	"exclude": [
		"**/node_modules/**"
	],
	"compilerOptions": {
		"types": [
			"jest",
			"node"
		]
	}
}

================
File: .github/workflows/audit.yaml
================
name: Audit dependencies

on:
  push:
    branches:
      - master
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  validate-dependencies:
    name: Validate production dependencies
    runs-on: ubuntu-latest
    continue-on-error: false
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js 16
        uses: actions/setup-node@v4
        with:
          node-version: 16
      - name: Prepare Environment
        run: |
          yarn install
        env:
          CI: true
      - name: Validate dependencies
        run: |
          yarn validate:dependencies
        env:
          CI: true
  validate-all-dependencies:
    name: Validate all dependencies
    runs-on: ubuntu-latest
    continue-on-error: true
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js 16
        uses: actions/setup-node@v4
        with:
          node-version: 16
      - name: Prepare Environment
        run: |
          yarn install
        env:
          CI: true
      - name: Validate dependencies
        run: |
          yarn validate:dev-dependencies
        env:
          CI: true

================
File: .github/workflows/sonar.yaml
================
on:
  # Trigger analysis when pushing in master or pull requests, and when creating
  # a pull request.
  push:
    branches:
      - master
  pull_request:
    types: [opened, synchronize, reopened]
name: SonarCloud
jobs:
  sonarcloud:
    name: SonarCloud
    runs-on: ubuntu-latest
    if: ${{ github.repository_owner == 'nrkno' }}

    steps:
      - uses: actions/checkout@v4
        with:
          # Disabling shallow clone is recommended for improving relevancy of reporting
          fetch-depth: 0
          persist-credentials: false

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 16
      - name: Prepare Environment
        run: |
          yarn
        env:
          CI: true

      - name: SonarCloud Scan
        uses: sonarsource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

================
File: packages/connector/src/connection/mosSocketServer.ts
================
import { Server, Socket } from 'net'
import { EventEmitter } from 'eventemitter3'
import { IncomingConnectionType, SocketServerEvent } from './socketConnection'
‚ãÆ----
export interface MosSocketServerEvents {
	[SocketServerEvent.CLIENT_CONNECTED]: (options: { socket: Socket; portDescription: IncomingConnectionType }) => void
	[SocketServerEvent.ERROR]: (err: Error) => void
	[SocketServerEvent.CLOSE]: () => void
}
export class MosSocketServer extends EventEmitter<MosSocketServerEvents>
‚ãÆ----
/** */
constructor(port: number, description: IncomingConnectionType, debug: boolean)
async dispose(sockets: Socket[]): Promise<void>
‚ãÆ----
// close clients
‚ãÆ----
// close server
‚ãÆ----
// this._socketServer.on('close', resolve)
‚ãÆ----
// close any server connections:
‚ãÆ----
/** */
async listen(): Promise<void>
‚ãÆ----
// already listening
‚ãÆ----
// Listens and handles error and events
‚ãÆ----
public setDebug(debug: boolean): void
get port(): number
get portDescription(): IncomingConnectionType
‚ãÆ----
/** */
private _onClientConnection(socket: Socket)
‚ãÆ----
/** */
private _onServerError(error: Error)
‚ãÆ----
// @todo: implement
‚ãÆ----
/** */
private _onServerClose()
‚ãÆ----
// @todo: implement
‚ãÆ----
private debugTrace(...strs: any[])
‚ãÆ----
// eslint-disable-next-line no-console

================
File: packages/connector/src/index.ts
================
// Backwards compatibility
import { xml2js, pad, addTextElement, xmlToObject } from '@mos-connection/helper'

================
File: packages/helper/src/mosModel/profile0/heartBeat.ts
================
import { getMosTypes, IMOSTime } from '@mos-connection/model'
‚ãÆ----
import { addTextElementInternal } from '../../utils/Utils'
import { MosMessage, PortType } from '../MosMessage'
‚ãÆ----
export class HeartBeat extends MosMessage
‚ãÆ----
/** */
constructor(port: PortType, time: IMOSTime | undefined, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile1/reqMosObjAll.ts
================
import { addTextElementInternal } from '../../utils/Utils'
import { MosMessage } from '../MosMessage'
‚ãÆ----
export class ReqMosObjAll extends MosMessage
‚ãÆ----
/** */
constructor(pause: number, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile2/roElementStat.ts
================
import { MosMessage } from '../MosMessage'
import { getMosTypes, IMOSObjectStatus, IMOSString128, IMOSTime } from '@mos-connection/model'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export enum ROElementStatType {
	RO = 'RO',
	STORY = 'STORY',
	ITEM = 'ITEM',
}
export interface ROElementStatOptions {
	type: ROElementStatType
	roId: IMOSString128
	storyId?: IMOSString128
	itemId?: IMOSString128
	objId?: IMOSString128
	itemChannel?: IMOSString128
	status: IMOSObjectStatus
}
export class ROElementStat extends MosMessage
‚ãÆ----
/** */
constructor(options: ROElementStatOptions, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile2/ROListAll.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSRunningOrder } from '@mos-connection/model'
import { XMLRunningOrderBase } from './xmlConversion'
‚ãÆ----
export class ROListAll extends MosMessage
‚ãÆ----
/** */
constructor(list: IMOSRunningOrder[], strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile3/index.ts
================


================
File: packages/helper/src/mosModel/profile3/mosListSearchableSchema.ts
================
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { IMOSListSearchableSchema } from '@mos-connection/model'
import { XMLMosListSearchableSchema } from './xmlConversion'
‚ãÆ----
export class MosListSearchableSchema extends MosMessage
‚ãÆ----
constructor(options: IMOSListSearchableSchema, strict: boolean)
‚ãÆ----
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile3/mosReqObjList.ts
================
import { IMOSRequestObjectList } from '@mos-connection/model'
import { MosMessage } from '../MosMessage'
‚ãÆ----
import { XMLMosRequestObjectList } from './xmlConversion'
‚ãÆ----
export class MosReqObjList extends MosMessage
‚ãÆ----
constructor(options: IMOSRequestObjectList, strict: boolean)
‚ãÆ----
get messageXMLBlocks(): XMLBuilder.XMLElement

================
File: packages/helper/src/mosModel/profile4/roStory.ts
================
import { MosMessage } from '../MosMessage'
import { IMOSROFullStory, IMOSItem } from '@mos-connection/model'
import { XMLROStoryBase } from '../profile2/xmlConversion'
import { XMLMosExternalMetaData, XMLMosObjects, XMLObjectPaths } from '../profile1/xmlConversion'
import { addTextElementInternal } from '../../utils/Utils'
‚ãÆ----
export class ROStory extends MosMessage
‚ãÆ----
/** */
constructor(private fullStory: IMOSROFullStory, strict: boolean)
‚ãÆ----
/** */
get messageXMLBlocks(): XMLBuilder.XMLElement
‚ãÆ----
// TODO: mosAbstract?: string?
// TODO: Channel?: MosString128?
// TODO: MacroIn?: MosString128?
// TODO: MacroOut?: MosString128?
‚ãÆ----
// Note: the <mosObj> is sent in roStorySend
‚ãÆ----
// TODO: what is this?

================
File: packages/helper/src/stringify/stringifyMosObject.ts
================
import { getMosTypes, IMOSDuration, IMOSString128, IMOSTime, MosTypes, stringifyMosType } from '@mos-connection/model'
‚ãÆ----
/**
 * Converts a MOS data object,
 * replacing Mos-centric types with their stringified equivalents
 */
export function stringifyMosObject<T extends
function stringifyMosObjectInner(o: any, mosTypes: MosTypes):
‚ãÆ----
} else if (value !== undefined) o2[key] = value // Omit undefined values
‚ãÆ----
type DeepReplace<T, M extends [any, any]> = {
	[P in keyof T]: T[P] extends M[0] ? Replacement<M, T[P]> : T[P] extends object ? DeepReplace<T[P], M> : T[P]
}
type Replacement<M extends [any, any], T> = M extends any ? ([T] extends [M[0]] ? M[1] : never) : never
‚ãÆ----
export type Stringified<Original> = DeepReplace<
	Original,
	[IMOSString128, string] | [IMOSDuration, string] | [IMOSTime, string]
>

================
File: packages/helper/src/utils/ensureMethods.ts
================
import { AnyXMLObject, AnyXMLValue, AnyXMLValueSingular } from '@mos-connection/model'
import { assertStringLiteral, isEmpty } from '../mosModel/lib'
‚ãÆ----
/**
 * Ensures that the returned value is an array.
 * If the input is not an array, it will be wrapped in an array.
 */
export function ensureArray<A, B>(v: A | B | B[]): (A | B)[]
export function ensureArray<T>(v: T | T[]): T[]
‚ãÆ----
/**
 * Ensures that the returned value is a string literal.
 * If the input value is not of the correct type, will throw (if strict) or return the fallback value.
 */
export function ensureStringLiteral<T extends string>(
	xmlValue: AnyXMLValue,
	options: T[],
	strict: boolean,
	fallback: T
): T
/**
 * Ensures that the returned value is a string.
 * If the input value is not of the correct type, will throw (if strict) or return the fallback value.
 */
export function ensureString(value: AnyXMLValue, strict: boolean, fallback = ''): string
‚ãÆ----
/**
 * Ensures that the returned value is an object.
 * If the input value is not of the correct type, will throw (if strict) or return the fallback value.
 */
export function ensureXMLObject(value: AnyXMLValue, strict: boolean, fallback: AnyXMLObject =
‚ãÆ----
/**
 * Ensures that the returned value is a singular value (ie a string or undefined).
 * If the input value is not of the correct type, will throw (if strict) or return the fallback value.
 */
export function ensureSingular(value: AnyXMLValue, strict: boolean): AnyXMLValueSingular
‚ãÆ----
// Quick-fix if it is in a xml element:
‚ãÆ----
// Quick-fix for empty object
‚ãÆ----
/**
 * Ensures that the returned value is an array containing only singular values
 * If the input value is not of the correct type, will throw (if strict) or return an empty array
 */
export function ensureSingularArray(value: AnyXMLValue, strict: boolean): AnyXMLValueSingular[]
/**
 * Ensures that the returned value is an array containing only XMLObjects
 * If the input value is not of the correct type, will throw (if strict) or return an empty array
 */
export function ensureXMLObjectArray(value: AnyXMLValue, strict: boolean): AnyXMLObject[]
‚ãÆ----
export function isSingular(value: AnyXMLValue): value is AnyXMLValueSingular
export function isSingularArray(value: AnyXMLValue): value is AnyXMLValueSingular[]
export function isXMLObject(value: AnyXMLValue): value is AnyXMLObject
function isXMLTextElement(xml: any): xml is TextElement
interface TextElement {
	$type: 'text'
	$name: string
	text: string
}

================
File: packages/helper/src/utils/Errors.ts
================
/** An error that occurred while parsing a reply to a sent mos message */
export class MosReplyError extends Error
‚ãÆ----
constructor(orgError: unknown, public readonly parsedReply: unknown | undefined)

================
File: packages/model/src/mosTypes/lib.ts
================
export function pad(n: string | number, width: number, z?: string): string

================
File: packages/quick-mos/input/runningorders/README.md
================
Quick-MOS will monitor the contents of this folder.

Put any RunningOrders that you want the Quick-MOS server to expose in here.

Quick-MOS supports

- ts files (see examples in the folder)
- json files (see examples in the folder)
- Sofie Playlist/Rundown Snapshots

================
File: packages/quick-mos/input/config.ts
================
import { Config } from '../src/.' // eslint-disable-line node/no-unpublished-import
‚ãÆ----
// This is the NCS-id, you might need to specify it in your mos-client that connects to Quick-MOS.
‚ãÆ----
// ports: {
// Set these if you have a mos-client running on other ports than standard:
// lower: 11540,
// upper: 11541,
// query: 11542,
// },
‚ãÆ----
// Set these if you want quick-mos to run on other ports than standard:
‚ãÆ----
// Set to true to turn on debug-logging:

================
File: packages/quick-mos/input/util.ts
================
import { MosModel } from '@mos-connection/connector'
import type { IMOSROFullStory, IMOSString128 } from '@mos-connection/model'
‚ãÆ----
export type NormalizeMosAttributes<T> = {
	[P in keyof T]: T[P] extends IMOSString128
		? string
		: T[P] extends IMOSString128 | undefined
		? string | undefined
		: T[P] extends string | number | null | undefined
		? T[P]
		: NormalizeMosAttributes<T[P]>
}
‚ãÆ----
export function fixStoryBody(
	stories: Array<NormalizeMosAttributes<IMOSROFullStory>>
): Array<NormalizeMosAttributes<IMOSROFullStory>>

================
File: packages/helper/src/mosModel/profile3/xmlConversion.ts
================
import {
	AnyXMLValue,
	IMOSListSearchableSchema,
	IMOSObjectList,
	IMOSRequestObjectList,
	IMOSSearchField,
} from '@mos-connection/model'
import { omitUndefined } from '../lib'
import { getParseMosTypes, getXMLAttributes } from '../parseMosTypes'
import { addTextElementInternal } from '../../utils/Utils'
import { XMLMosObjects } from '../profile1'
import { ParseError } from '../ParseError'
import { ensureXMLObject, ensureXMLObjectArray, isXMLObject } from '../../utils/ensureMethods'
/* eslint-disable @typescript-eslint/no-namespace */
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSRequestObjectList
export function toXML(xml: XMLBuilder.XMLElement, objList: IMOSRequestObjectList, strict: boolean): void
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSObjectList
export function toXML(xml: XMLBuilder.XMLElement, objList: IMOSObjectList, strict: boolean): void
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSListSearchableSchema
export function toXML(xml: XMLBuilder.XMLElement, schema: IMOSListSearchableSchema, strict: boolean): void

================
File: packages/helper/src/mosModel/profile4/xmlConversion.ts
================
import { IMOSROFullStoryBodyItem, IMOSROFullStory, AnyXMLValue } from '@mos-connection/model'
import { XMLROStory, XMLMosItem } from '../profile2/xmlConversion'
import { omitUndefined } from '../lib'
import { getParseMosTypes } from '../parseMosTypes'
import { ParseError } from '../ParseError'
import { ensureXMLObject, ensureXMLObjectArray } from '../../utils/ensureMethods'
‚ãÆ----
/* eslint-disable @typescript-eslint/no-namespace */
‚ãÆ----
export function fromXML(path: string, xml0: AnyXMLValue, strict: boolean): IMOSROFullStory
‚ãÆ----
function fromXMLStoryBody(xml: AnyXMLValue, strict: boolean): IMOSROFullStoryBodyItem[]
‚ãÆ----
/*
	// Not able to implement this currently, need to change {arrayNotation: true} in xml2json option
	let elementKeys = Object.keys(xml)
	elementKeys.forEach((key: string) => {
		// let elements
		let d = xml[key]

		if (!Array.isArray(d)) d = [d]

		d.forEach((el: any) => {
			let bodyItem: IMOSROFullStoryBodyItem = {
				Type: key,
				Content: el
			}
			body.push(bodyItem)
		})
	})
	*/
‚ãÆ----
// Temporary implementation:

================
File: packages/helper/src/mosModel/index.ts
================
import { AnyXMLObject } from '@mos-connection/model'
/** @deprecated use AnyXMLObject instead  */
export type AnyXML = AnyXMLObject // for backwards compatibility

================
File: packages/helper/src/mosModel/MosMessage.ts
================
import { getMosTypes, MosTypes } from '@mos-connection/model'
‚ãÆ----
import { addTextElementInternal } from '../utils/Utils'
‚ãÆ----
export type PortType = 'upper' | 'lower' | 'query'
export abstract class MosMessage
‚ãÆ----
constructor(public port: PortType, protected readonly strict: boolean)
‚ãÆ----
private static getNewMessageID(): number
‚ãÆ----
// increments and returns a signed 32-bit int counting from 1, resetting to 1 when wrapping
‚ãÆ----
/** */
prepare(messageID?: number): void
‚ãÆ----
/** */
get messageID(): number
‚ãÆ----
/** */
toString(): string
‚ãÆ----
/** */
protected abstract get messageXMLBlocks(): XMLBuilder.XMLElement
‚ãÆ----
/**  */

================
File: packages/helper/src/mosModel/ParseError.ts
================
/*
  Typical use case:
  function (xml) {
    try {
      // do something with xml.storyBody
    } catch (e) {
      throw ParseError.handleCaughtError('storyBody', e)
    }
  }

*/
‚ãÆ----
export class ParseError
‚ãÆ----
static handleCaughtError(basePath: string, e: unknown): ParseError
static isParseError(e: unknown): e is ParseError
static fromError(e: Error, path: string): ParseError
‚ãÆ----
static handleError<T>(func: () => T, path: string): T
‚ãÆ----
private constructor(path: string, message: string, stack?: string)
‚ãÆ----
this.message = '' // Updated in updateVars()
‚ãÆ----
public addBreadcrumb(path: string): void
private updateVars()
‚ãÆ----
toString(): string

================
File: packages/model/src/index.ts
================


================
File: packages/model/src/xmlParse.ts
================
/** Parsed xml data objects */
export type AnyXMLObject = { [key: string]: AnyXMLValue }
/** Parsed xml data values */
export type AnyXMLValue = AnyXMLValueSingular | AnyXMLValueSingular[] | AnyXMLObject | AnyXMLObject[]
/** Parsed xml data values, singular */
export type AnyXMLValueSingular = string | undefined

================
File: package.json
================
{
	"name": "mos-connection-monorepo",
	"version": "0.0.0",
	"repository": "https://github.com/nrkno/tv-automation-mos-connection",
	"private": true,
	"workspaces": [
		"packages/*"
	],
	"scripts": {
		"prepare": "husky install",
		"lerna": "lerna",
		"postinstall": "node scripts/update-packages.mjs",
		"ci": "run build && run lint && run test",
		"release:set-version": "lerna version --exact --no-changelog --no-push --yes && yarn fix-version",
		"release:bump-release": "lerna version --exact --conventional-commits --conventional-graduate --tag-version-prefix='v' --no-push --force-publish='*' && yarn fix-version",
		"release:bump-prerelease": "lerna version --exact --conventional-commits --conventional-prerelease --tag-version-prefix='v' --no-push --force-publish='*' && yarn fix-version",
		"release:bump-prerelease-ci": "lerna version --exact --conventional-commits --conventional-prerelease --tag-version-prefix='v' --no-push --force-publish='*'",
		"fix-version": "node scripts/fix-version.js",
		"setup": "lerna bootstrap",
		"reset": "node scripts/reset.js",
		"build": "lerna run build --stream",
		"build:changed": "lerna run build --since head --exclude-dependents --stream",
		"lint": "lerna exec --parallel -- run -T eslint . --ext .ts,.tsx",
		"lintfix": "run lint --fix",
		"lint:changed": "lerna exec --since origin/master --include-dependents -- run -T eslint . --ext .js,.jsx,.ts,.tsx",
		"test": "lerna run test --stream",
		"test:changed": "lerna run --since origin/master --include-dependents test",
		"test:coverage": "lerna run test:coverage --stream",
		"lint-staged": "./node_modules/.bin/lint-staged",
		"prettier": "cd $INIT_CWD && \"$PROJECT_CWD/node_modules/.bin/prettier\"",
		"eslint": "cd $INIT_CWD && \"$PROJECT_CWD/node_modules/.bin/eslint\"",
		"validate:dependencies": "yarn lerna exec --parallel yarn validate:dependencies && yarn license-validate",
		"validate:dev-dependencies": "yarn lerna exec --parallel yarn validate:dev-dependencies",
		"license-validate": "yarn sofie-licensecheck --allowPackages \"mos-examples@0.0.0;quick-mos@0.0.0\""
	},
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "2.5.1",
		"@types/jest": "^29.5.2",
		"deep-extend": "^0.6.0",
		"glob": "^7.2.3",
		"jest": "^29.5.0",
		"lerna": "^6.6.2",
		"lodash": "^4.17.21",
		"rimraf": "^5.0.1",
		"ts-jest": "^29.1.0",
		"typescript": "~4.9.5"
	},
	"engines": {
		"node": ">=14.18.0"
	},
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"packageManager": "yarn@3.6.0"
}

================
File: README.md
================
# MOS-Connection

[![Tests](https://github.com/nrkno/sofie-mos-connection/actions/workflows/node.yaml/badge.svg)](https://github.com/nrkno/sofie-mos-connection/actions/workflows/node.yaml)
[![codecov](https://codecov.io/gh/nrkno/sofie-mos-connection/branch/master/graph/badge.svg?token=LQL02uXajF)](https://codecov.io/gh/nrkno/sofie-mos-connection)
[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=nrkno_tv-automation-mos-connection&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=nrkno_tv-automation-mos-connection)

[![@mos-connection/connector NPM Version](https://img.shields.io/npm/v/%40mos-connection%2Fconnector)](https://www.npmjs.com/package/@mos-connection/connector)
[![@mos-connection/helper NPM Version](https://img.shields.io/npm/v/%40mos-connection%2Fhelper)](https://www.npmjs.com/package/@mos-connection/helper)
[![@mos-connection/model NPM Version](https://img.shields.io/npm/v/%40mos-connection%2Fmodel)](https://www.npmjs.com/package/@mos-connection/model)

_MOS-Connection_ is a Node.js library to communicate, using the [MOS Protocol](http://mosprotocol.com/), with systems such as Newsroom Computer Systems (NRCS) or other MOS devices.

Features include:

- Acting as a _MOS Device_ (ie a client), connecting to an NRCS.
- Acting as a _NRCS_ (ie a server), allowing other MOS Devices to connect to it.
- Helpful tools for developing _MOS Plugins_ and parsing MOS data.
- A simple tool for testing MOS connections, called _Quick-MOS_.

This library is developed as a part of the [**Sofie** TV Automation System](https://github.com/nrkno/Sofie-TV-automation/).

## General Sofie System Information

- [_Sofie_ Documentation](https://nrkno.github.io/sofie-core/)
- [_Sofie_ Releases](https://nrkno.github.io/sofie-core/releases)
- [Contribution Guidelines](CONTRIBUTING.md)
- [License](LICENSE)

---

## Packages

MOS-Connection consists of 4 packages:

- **@mos-connection/connector** is a Node.js library is used to connect to MOS devices or act as a MOS Server/NCS.
  The `helper` and `model` functionality is included in this library as well.
- **@mos-connection/helper** is a library that provides various functions useful for those that prepare/handle data that will be sent to (or has been received by) the MOS-connection.
  The `model` functionality is included in this library as well.
- **@mos-connection/model** is a library that contains types and enums, useful for applications that handles MOS-data.
- There is also a helper application **QuickMos** designed to be a minimal mock MOS server for testing client applications.

## Getting Started

### Installation

```bash
npm install @mos-connection/connector
```

### Usage

\_See more examples in the [examples](/packages/examples/src) folder, or the [QuickMos](/packages/quick-mos/src/index.ts) implementation!

```typescript
import { MosConnection } from '@mos-connection/connector'

let mos = new MosConnection(new ConnectionConfig({
	mosID: 'my.mos.application',
	acceptsConnections: true,
	profiles: {
		'0': true,
        '1': true,
        '2': true,
        '4': true
	},
	openRelay: true
	debug: false
}))
mos.onConnection((device: MosDevice) => { // called whenever there is a new connection to a mos-device
	if (device.hasConnection) { // true if we can send messages to the mos-server
	    device.getMachineInfo().then((lm) => {
			console.log('Machineinfo', lm)
		})
	}
	// Setup callbacks to pipe data:
	device.onRequestMachineInfo(() => {})
	device.onCreateRunningOrder((ro) => {})
	device.onDeleteRunningOrder((RunningOrderID: MosString128) => {})
	device.onReadyToAir(() => {})
	// ...
})
```

### Quick-MOS

"Quick-MOS" is a simple MOS application that can be used to test the MOS-connection library.

It reads data-files from disk and pretends to be an NRCS, so you can connect other MOS-clients to it.

See [Quick-MOS](/packages/quick-mos/README.md) for more information.

## MOS Support

The MOS-Connection library currently supports the [MOS Protocol version **2.8.5**](https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS_Protocol_Version_2.8.5_Final.htm).

### Supported MOS Profiles

| Profile   | Status                |
| --------- | --------------------- |
| Profile 0 | Implemented           |
| Profile 1 | Implemented           |
| Profile 2 | Implemented           |
| Profile 3 | Implemented           |
| Profile 4 | Implemented           |
| Profile 5 | Not implemented (yet) |
| Profile 6 | Not implemented (yet) |
| Profile 7 | Not implemented (yet) |

Pull Requests for the remaining profiles would be happily accepted!

---

_The NRK logo is a registered trademark of Norsk rikskringkasting AS. The license does not grant any right to use, in any way, any trademarks, service marks or logos of Norsk rikskringkasting AS._

================
File: .github/workflows/publish-prerelease.yaml
================
name: Publish prerelease

on:
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  test:
    name: Test on node ${{ matrix.node_version }} and ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        node_version: ['14', '16', '18', '20']
        os: [ubuntu-latest] # [windows-latest, macOS-latest]

    timeout-minutes: 5
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js ${{ matrix.node_version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node_version }}
      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-modules-${{ hashFiles('**/yarn.lock') }}

      - name: Prepare Environment
        run: |
          yarn
          yarn build
        env:
          CI: true
      - name: Run unit tests
        run: |
          yarn test -- --maxWorkers=2 --forceExit
        env:
          CI: true

  prerelease:
    name: Publish to NPM
    runs-on: ubuntu-latest
    timeout-minutes: 15

    needs:
      - test

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
      - name: Use Node.js 16
        uses: actions/setup-node@v4
        with:
          node-version: 16
      - name: Check release is desired
        id: do-publish
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "No Token"
          elif [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "Publish nightly"
            echo "publish=nightly" >> $GITHUB_OUTPUT
          else
            echo "Publish experimental"
            echo "publish=experimental" >> $GITHUB_OUTPUT
          fi
      - name: Prepare Environment
        if: ${{ steps.do-publish.outputs.publish }}
        run: |
          yarn install
          yarn build
        env:
          CI: true
      - name: Bump version
        if: ${{ steps.do-publish.outputs.publish }}
        run: |
          git config --global user.email "info@superfly.tv"
          git config --global user.name "superflytvab"

          COMMIT_TIMESTAMP=$(git log -1 --pretty=format:%ct HEAD)
          COMMIT_DATE=$(date -d @$COMMIT_TIMESTAMP +%Y%m%d-%H%M%S)
          GIT_HASH=$(git rev-parse --short HEAD)
          PRERELEASE_TAG=nightly-$(echo "${{ github.ref_name }}" | sed -r 's/[^a-z0-9]+/-/gi')
          yarn release:bump-prerelease-ci --no-changelog --no-commit-hooks --preid "$PRERELEASE_TAG-$COMMIT_DATE-$GIT_HASH" prerelease --yes
        env:
          CI: true
      - name: Publish to NPM
        if: ${{ steps.do-publish.outputs.publish }}
        run: |
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" >> ~/.npmrc
          yarn lerna publish from-package --tag-version-prefix='' --dist-tag ${{ steps.do-publish.outputs.publish }} --yes --no-verify-access
        env:
          CI: true

================
File: packages/connector/src/connection/mosMessageParser.ts
================
import { EventEmitter } from 'eventemitter3'
import { MosModel, xml2js } from '@mos-connection/helper'
‚ãÆ----
export interface MosMessageParserEvents {
	message: (parsedData: ParsedMosMessage, messageString: string) => void
}
export class MosMessageParser extends EventEmitter<MosMessageParserEvents>
‚ãÆ----
constructor(private description: string)
‚ãÆ----
public parseMessage(messageString: string): void
‚ãÆ----
// parse as many messages as possible from the data
‚ãÆ----
// whitespace before a mos message is junk
‚ãÆ----
// Nothing was plucked, so abort
‚ãÆ----
private _tryParseData()
‚ãÆ----
const startMatch = '<mos>' // <mos>
const endMatch = '</mos>' // </mos>
‚ãÆ----
// No start tag, so looks like we have jibberish
‚ãÆ----
// trim off anything before <mos>, as we'll never be able to parse that anyway.
‚ãÆ----
// We have an end tag too
‚ãÆ----
/** null = message is not complete */
‚ãÆ----
// fast-path:
‚ãÆ----
// Figure out where in the message the end tag closes the start tag:
‚ãÆ----
// Hmm, something is wrong, there should never be more end tags than start tags
‚ãÆ----
// trim off anything before this end tag, we'll never be able to parse that anyway.
‚ãÆ----
// We have a complete message, so pluck it out
‚ãÆ----
const data = xml2js(messageString) as any as ParsedMosMessage // , { compact: true, trim: true, nativeType: true })
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
// this.emit('error', e)
‚ãÆ----
private debugTrace(str: string)
‚ãÆ----
// Suppress console spam:
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
/** Returns a list of indexes for the occurences of searchString in str */
private indexesOf(str: string, searchString: string): number[]
‚ãÆ----
// ^ Just to avoid an infinite loop
‚ãÆ----
/** Definition of an incoming MOS Message */
export interface ParsedMosMessage {
	mos: {
		ncsID: string
		mosID: string
		messageID?: string // Note: messageID is optional for some messages in older versions of the MOS Protocol

		[key: string]: MosModel.AnyXMLValue
	}
}
‚ãÆ----
messageID?: string // Note: messageID is optional for some messages in older versions of the MOS Protocol

================
File: packages/helper/src/mosModel/profile2/xmlConversion.ts
================
import {
	IMOSROStory,
	IMOSItem,
	IMOSROFullStory,
	IMOSRunningOrderBase,
	IMOSRunningOrder,
	IMOSROAckStory,
	IMOSROAckItem,
	IMOSROAckObject,
	AnyXMLValue,
} from '@mos-connection/model'
import { has, omitUndefined } from '../lib'
import { ensureArray, ensureXMLObject } from '../../utils/ensureMethods'
import { ROAck } from './ROAck'
import { XMLMosExternalMetaData, XMLMosObjects, XMLObjectPaths } from '../profile1/xmlConversion'
import { addTextElementInternal } from '../../utils/Utils'
import { getParseMosTypes } from '../parseMosTypes'
import { ParseError } from '../ParseError'
/* eslint-disable @typescript-eslint/no-namespace */
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): ROAck
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSRunningOrderBase
export function toXML(xmlRo: XMLBuilder.XMLElement, ro: IMOSRunningOrderBase, strict: boolean): void
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSRunningOrder
‚ãÆ----
export function fromXML(path: string, xmlStories: AnyXMLValue, strict: boolean): IMOSROStory[]
‚ãÆ----
export function toXML(
		xmlStory: XMLBuilder.XMLElement,
		story: IMOSROStory | IMOSROFullStory,
		strict: boolean
): void
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSROStory
‚ãÆ----
// TODO: Add & test Number, ObjectID, MOSID, mosAbstract, Paths
// Channel, EditorialStart, EditorialDuration, UserTimingDuration, Trigger, MacroIn, MacroOut, MosExternalMetaData
// MosExternalMetaData: handleError(MOSExternalMetaData.fromXML(xml.mosExternalMetadata], 'mosExternalMetadata').
‚ãÆ----
// Note: the <storyBody> is sent in roStorySend
‚ãÆ----
export function toXML(xmlRoot: XMLBuilder.XMLElement, story: IMOSROStory, strict: boolean): void
‚ãÆ----
export function fromXML(path: string, xmlItems: AnyXMLValue, strict: boolean): Array<IMOSItem>
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSItem
‚ãÆ----
// Note: the <mosObj> is sent in roStorySend
‚ãÆ----
export function toXML(root: XMLBuilder.XMLElement, item: IMOSItem, strict: boolean): void
‚ãÆ----
// TODO: MosObjects

================
File: packages/helper/src/utils/Utils.ts
================
import { xml2js as xmlParser } from 'xml-js'
‚ãÆ----
import {
	AnyXMLValue,
	getMosTypes,
	IMOSDuration,
	IMOSString128,
	IMOSTime,
	stringifyMosType,
} from '@mos-connection/model'
import { MosModel } from '..'
‚ãÆ----
export function xml2js(messageString: string): MosModel.AnyXMLObject
‚ãÆ----
nativeType: false, // we want to NOT auto-convert types, to avoid ambiguity
‚ãÆ----
// common tags we typically want to know the order of the contents of:
‚ãÆ----
/**
	 * Doing a post-order tree traversal we try to make the objectified tree as compact as possible.
	 * Whenever we find an "orderedTag" we keep the order of it's children.
	 *
	 * ps: post-order means we make a node's children as compact as possible first, and then try to make
	 * that node compact.
	 */
const concatChildrenAndTraverseObject = (element:
‚ãÆ----
// pure text node, hoist it up:
‚ãÆ----
// leave it as is
‚ãÆ----
// if the element name is contained in the set of orderedTag names we don't make it any more compact
‚ãÆ----
// make array compact:
‚ãÆ----
// might contain something useful like attributes
‚ãÆ----
// all elements are unique
‚ãÆ----
export function addTextElement(
	root: XMLBuilder.XMLElement,
	elementName: string,
	text?: string | number | null | IMOSString128 | IMOSTime | IMOSDuration,
	attributes?: { [key: string]: string },
	strict = true
): XMLBuilder.XMLElement
export function addTextElementInternal(
	root: XMLBuilder.XMLElement,
	elementName: string,
	content: AnyXMLValue | number | null | IMOSString128 | IMOSTime | IMOSDuration,
	attributes: { [key: string]: string | undefined } | undefined,
	strict: boolean
): XMLBuilder.XMLElement
/**
 * Utility-function to convert a XMLBuilder.XMLElement into the generic object which can be sent
 * into the ***.fromXML(xml:any) methods in MosModel
 */
export function xmlToObject(root: XMLBuilder.XMLElement): any
‚ãÆ----
// @ts-expect-error hack
‚ãÆ----
// @ts-expect-error hack
‚ãÆ----
// @ts-expect-error hack
‚ãÆ----
obj[ch.name] = [obj[ch.name]] // make an array

================
File: packages/helper/src/index.ts
================
// not addTextElementInternal

================
File: packages/model/src/mosTypes/mosString128.ts
================
export interface IMOSString128 {
	_mosString128: string
	/** @deprecated use getMosTypes().mosString128.stringify() instead! */
	toString: never
}
‚ãÆ----
/** @deprecated use getMosTypes().mosString128.stringify() instead! */
‚ãÆ----
export function create(anyValue: AnyValue, strict: boolean): IMOSString128
‚ãÆ----
// is empty?
‚ãÆ----
export type AnyValue = string | { text: string; type: string } | IMOSString128 | undefined
‚ãÆ----
export function validate(mosString128: IMOSString128, strict: boolean): void
export function valueOf(mosString128: IMOSString128): string
‚ãÆ----
if (typeof mosString128 === 'string') return mosString128 // helpful hack
‚ãÆ----
export function stringify(mosString128: IMOSString128): string
‚ãÆ----
if (typeof mosString128 === 'string') return mosString128 // helpful hack
‚ãÆ----
export function is(mosString128: IMOSString128 | any): mosString128 is IMOSString128
export function fallback(): IMOSString128

================
File: packages/model/src/model.ts
================
import { IMOSTime, IMOSString128, IMOSDuration, IMOSExternalMetaData } from './mosTypes'
import { AnyXMLValue } from './xmlParse'
‚ãÆ----
export interface IMOSROAction {
	RunningOrderID: IMOSString128
}
export interface IMOSStoryAction extends IMOSROAction {
	StoryID: IMOSString128
}
export interface IMOSItemAction extends IMOSStoryAction {
	ItemID: IMOSString128
}
export interface IMOSROReadyToAir {
	ID: IMOSString128
	Status: IMOSObjectAirStatus
}
export interface IMOSRunningOrderStatus {
	ID: IMOSString128
	Status: IMOSObjectStatus
	Time: IMOSTime
}
export interface IMOSStoryStatus {
	RunningOrderId: IMOSString128
	ID: IMOSString128
	Status: IMOSObjectStatus
	Time: IMOSTime
}
export interface IMOSItemStatus {
	RunningOrderId: IMOSString128
	StoryId: IMOSString128
	ID: IMOSString128
	Status: IMOSObjectStatus
	Time: IMOSTime
	ObjectId?: IMOSString128
	Channel?: IMOSString128
}
export interface IMOSRunningOrderBase {
	ID: IMOSString128 // running order id
	Slug: IMOSString128
	DefaultChannel?: IMOSString128
	EditorialStart?: IMOSTime
	EditorialDuration?: IMOSDuration
	Trigger?: IMOSString128
	MacroIn?: IMOSString128
	MacroOut?: IMOSString128
	MosExternalMetaData?: Array<IMOSExternalMetaData>
}
‚ãÆ----
ID: IMOSString128 // running order id
‚ãÆ----
export interface IMOSRunningOrder extends IMOSRunningOrderBase {
	Stories: Array<IMOSROStory>
}
export interface IMOSStory {
	ID: IMOSString128
	Slug?: IMOSString128
	Number?: IMOSString128
	MosExternalMetaData?: Array<IMOSExternalMetaData>
}
export interface IMOSROStory extends IMOSStory {
	Items: Array<IMOSItem>
}
export interface IMOSROFullStory extends IMOSStory {
	RunningOrderId: IMOSString128
	Body: Array<IMOSROFullStoryBodyItem>
}
‚ãÆ----
export type IMOSROFullStoryBodyItem = IMOSROFullStoryBodyStoryItem | IMOSROFullStoryBodyOtherItem
export type IMOSROFullStoryBodyStoryItem = {
	itemType: 'storyItem'
	Type: 'storyItem'
	Content: IMOSItem // TODO: Make this stricter? IMOSItemObject??
}
‚ãÆ----
Content: IMOSItem // TODO: Make this stricter? IMOSItemObject??
‚ãÆ----
export type IMOSROFullStoryBodyOtherItem = {
	itemType: 'other'
	Type: string // e.g. 'p'
	Content: AnyXMLValue
}
‚ãÆ----
Type: string // e.g. 'p'
‚ãÆ----
export interface IMOSItem {
	ID: IMOSString128
	Slug?: IMOSString128
	ObjectSlug?: IMOSString128
	ObjectID: IMOSString128
	MOSID: string
	mosAbstract?: string
	Paths?: Array<IMOSObjectPath>
	Channel?: IMOSString128
	EditorialStart?: number
	EditorialDuration?: number
	Duration?: number
	TimeBase?: number
	UserTimingDuration?: number
	Trigger?: AnyXMLValue
	MacroIn?: IMOSString128
	MacroOut?: IMOSString128
	MosExternalMetaData?: Array<IMOSExternalMetaData>
	MosObjects?: Array<IMOSObject>
}
‚ãÆ----
export interface IMOSAck {
	ID: IMOSString128
	Revision: number // max 999
	Status: IMOSAckStatus
	Description: IMOSString128
}
‚ãÆ----
Revision: number // max 999
‚ãÆ----
export interface IMOSROAck {
	ID: IMOSString128 // Running order id
	Status: IMOSString128 // OK or error desc
	Stories: Array<IMOSROAckStory>
}
‚ãÆ----
ID: IMOSString128 // Running order id
Status: IMOSString128 // OK or error desc
‚ãÆ----
export interface IMOSROAckStory {
	ID: IMOSString128 // storyID
	Items: Array<IMOSROAckItem>
}
‚ãÆ----
ID: IMOSString128 // storyID
‚ãÆ----
export interface IMOSROAckItem {
	ID: IMOSString128
	Channel: IMOSString128
	Objects: Array<IMOSROAckObject>
}
‚ãÆ----
export interface IMOSROAckObject {
	Status: 'OK' | string
	ID: IMOSString128
}
‚ãÆ----
export interface IProfiles {
	[key: string]: boolean | undefined
	'0': boolean
	'1'?: boolean
	'2'?: boolean
	'3'?: boolean
	'4'?: boolean
	'5'?: boolean
	'6'?: boolean
	'7'?: boolean
}
‚ãÆ----
/** https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObj */
export interface IMOSObject {
	ID?: IMOSString128
	Slug: IMOSString128
	MosAbstract?: AnyXMLValue // xml json
	/** A stringified version of MosAbstract, where all HTML have been flattened */
	MosAbstractStr?: string
	Group?: string
	Type: IMOSObjectType
	TimeBase: number
	Revision?: number // max 999
	Duration: number
	Status?: IMOSObjectStatus
	AirStatus?: IMOSObjectAirStatus
	Paths?: Array<IMOSObjectPath>
	CreatedBy?: IMOSString128
	Created?: IMOSTime
	ChangedBy?: IMOSString128 // if not present, defaults to CreatedBy
	Changed?: IMOSTime // if not present, defaults to Created
	Description?: AnyXMLValue // xml json
	/** A stringified version of Description, where all HTML have been flattened */
	DescriptionStr?: string
	MosExternalMetaData?: Array<IMOSExternalMetaData>
	MosItemEditorProgID?: IMOSString128
}
‚ãÆ----
MosAbstract?: AnyXMLValue // xml json
/** A stringified version of MosAbstract, where all HTML have been flattened */
‚ãÆ----
Revision?: number // max 999
‚ãÆ----
ChangedBy?: IMOSString128 // if not present, defaults to CreatedBy
Changed?: IMOSTime // if not present, defaults to Created
Description?: AnyXMLValue // xml json
/** A stringified version of Description, where all HTML have been flattened */
‚ãÆ----
/**
 * Returns selected object descriptions from a MOS.
 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObjList
 */
export interface IMOSObjectList {
	username: string
	queryID: string
	listReturnStart: number
	listReturnEnd: number
	listReturnTotal: number
	listReturnStatus?: string
	list?: Array<IMOSObject>
}
‚ãÆ----
/**
 * mosReqObjList is a mechanism used by a NCS to retrieve only selected object descriptions from a MOS.
 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObjList
 */
export interface IMOSRequestObjectList {
	username: string
	queryID: IMOSString128
	listReturnStart: number | null
	listReturnEnd: number | null
	generalSearch: IMOSString128
	mosSchema: string
	searchGroups: Array<{
		searchFields: Array<IMOSSearchField>
	}>
}
/** @see IMOSRequestObjectList */
export interface IMOSSearchField {
	XPath: string
	sortByOrder?: number
	sortType?: string
}
‚ãÆ----
/**
 * mosListSearchableSchema is a mechanism used by the MOS to send a pointer to a schema in which searchable fields are defined for the NCS device.
 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosListSearchableSchema
 */
export interface IMOSListSearchableSchema {
	username: string
	mosSchema: string
}
‚ãÆ----
export enum IMOSObjectType {
	STILL = 'STILL',
	AUDIO = 'AUDIO',
	VIDEO = 'VIDEO',
	OTHER = 'OTHER', // unknown/not specified
}
‚ãÆ----
OTHER = 'OTHER', // unknown/not specified
‚ãÆ----
export enum IMOSObjectStatus {
	NEW = 'NEW',
	UPDATED = 'UPDATED',
	MOVED = 'MOVED',
	BUSY = 'BUSY',
	DELETED = 'DELETED',
	NCS_CTRL = 'NCS CTRL',
	MANUAL_CTRL = 'MANUAL CTRL',
	READY = 'READY',
	NOT_READY = 'NOT READY',
	PLAY = 'PLAY',
	STOP = 'STOP',
}
‚ãÆ----
export enum IMOSAckStatus {
	ACK = 'ACK',
	NACK = 'NACK',
}
‚ãÆ----
export enum IMOSObjectAirStatus {
	READY = 'READY',
	NOT_READY = 'NOT READY',
}
‚ãÆ----
export interface IMOSObjectPath {
	Type: IMOSObjectPathType
	Description: string
	Target: string // Max 255
}
‚ãÆ----
Target: string // Max 255
‚ãÆ----
export enum IMOSObjectPathType {
	PATH = 'PATH',
	PROXY_PATH = 'PROXY PATH',
	METADATA_PATH = 'METADATA PATH',
}
‚ãÆ----
export interface MosItemReplaceOptions {
	roID: IMOSString128
	storyID: IMOSString128
	item: IMOSItem
}
‚ãÆ----
export enum IMOSListMachInfoDefaultActiveXMode {
	MODALDIALOG = 'MODALDIALOG',
	MODELESS = 'MODELESS',
	CONTAINED = 'CONTAINED',
	TOOLBAR = 'TOOLBAR',
}
‚ãÆ----
export interface IMOSListMachInfo {
	/** Used in MOS ActiveX messages. Manufacturer: Text description. 128 chars max. */
	manufacturer: IMOSString128
	/** Model: Text description. 128 chars max. */
	model: IMOSString128
	/** HW Revision: 128 chars max. */
	hwRev: IMOSString128
	/** Software Revision: (MOS) Text description. 128 chars max., example: '2.1.0.37' */
	swRev: IMOSString128
	/** Date of Manufacture. */
	DOM: IMOSString128
	/** Serial Number: text serial number. 128 chars max. ex: '927748927' */
	SN: IMOSString128
	/** Identification of a Machine: text. 128 chars max. */
	ID: IMOSString128
	/** Time: Time object changed status. Format is YYYY-MM-DD'T'hh:mm:ss[,ddd]['Z'] */
	time: IMOSTime
	/** Operational Time: date and time of last machine start. Format is YYYY-MM-DD'T'hh:mm:ss[,ddd]['Z'] */
	opTime?: IMOSTime
	/** MOS Revision: Text description. 128 chars max. */
	mosRev: IMOSString128

	supportedProfiles: {
		deviceType: 'NCS' | 'MOS' | 'N/A'
		profile0?: boolean
		profile1?: boolean
		profile2?: boolean
		profile3?: boolean
		profile4?: boolean
		profile5?: boolean
		profile6?: boolean
		profile7?: boolean
	}
	/** defaultActiveX contains tags that describe the correct settings for the ActiveX control (NOTE: no two <defaultActivX> elements can have the same <mode> value). */
	defaultActiveX?: Array<IMOSDefaultActiveX>
	mosExternalMetaData?: Array<IMOSExternalMetaData>
}
‚ãÆ----
/** Used in MOS ActiveX messages. Manufacturer: Text description. 128 chars max. */
‚ãÆ----
/** Model: Text description. 128 chars max. */
‚ãÆ----
/** HW Revision: 128 chars max. */
‚ãÆ----
/** Software Revision: (MOS) Text description. 128 chars max., example: '2.1.0.37' */
‚ãÆ----
/** Date of Manufacture. */
‚ãÆ----
/** Serial Number: text serial number. 128 chars max. ex: '927748927' */
‚ãÆ----
/** Identification of a Machine: text. 128 chars max. */
‚ãÆ----
/** Time: Time object changed status. Format is YYYY-MM-DD'T'hh:mm:ss[,ddd]['Z'] */
‚ãÆ----
/** Operational Time: date and time of last machine start. Format is YYYY-MM-DD'T'hh:mm:ss[,ddd]['Z'] */
‚ãÆ----
/** MOS Revision: Text description. 128 chars max. */
‚ãÆ----
/** defaultActiveX contains tags that describe the correct settings for the ActiveX control (NOTE: no two <defaultActivX> elements can have the same <mode> value). */
‚ãÆ----
export interface IMOSDefaultActiveX {
	/** Used in MOS ActiveX messages. How the ActiveX Plug-In window appears in the NCS Host window: MODALDIALOG, MODELESS, CONTAINED, TOOLBAR. */
	mode: IMOSListMachInfoDefaultActiveXMode
	/** controlFileLocation is the file location for the default ActiveX control. */
	controlFileLocation: string
	/** Defined by MOS 128 characters max */
	controlSlug: IMOSString128
	/** This value represents the key/classId key used to load the ActiveX from the registry., ex: "contained.containedCTRL.1" */
	controlName: string
	/** This value represents the parameters that can be passed to an ActiveX. ex "URL=http:" */
	controlDefaultParams: string
}
‚ãÆ----
/** Used in MOS ActiveX messages. How the ActiveX Plug-In window appears in the NCS Host window: MODALDIALOG, MODELESS, CONTAINED, TOOLBAR. */
‚ãÆ----
/** controlFileLocation is the file location for the default ActiveX control. */
‚ãÆ----
/** Defined by MOS 128 characters max */
‚ãÆ----
/** This value represents the key/classId key used to load the ActiveX from the registry., ex: "contained.containedCTRL.1" */
‚ãÆ----
/** This value represents the parameters that can be passed to an ActiveX. ex "URL=http:" */

================
File: packages/model/src/mosTypes.ts
================
import { AnyXMLValue } from './xmlParse'
‚ãÆ----
/**
 * Returns utility-functions for handling of MosTypes.
 * @example
 * const mosTypes = getMosTypes(true)
 * const myString128 = mosTypes.mosString128.create('Hello world')
 * const myString = mosTypes.mosString128.stringify(myString128)
 * @param strict If true, creating out-of-spec values will throw an error (Example: Creating longer-than-128-characters long MosString128).
 */
export function getMosTypes(strict: boolean): MosTypes
export interface MosTypes {
	strict: boolean
	mosString128: MosType<MosString128.IMOSString128, string, MosString128.AnyValue>
	mosDuration: MosType<MosDuration.IMOSDuration, number, MosDuration.AnyValue>
	mosTime: MosType<MosTime.IMOSTime, number, MosTime.AnyValue>
}
/**
 * If value is a MosType, stringify it.
 * Throw error otherwise
 */
export function stringifyMosType(
‚ãÆ----
export interface MosType<Serialized, Value, CreateValue> {
	/** Creates a MosType using provided data. The MosType is then used in data sent into MOS-connection  */
	create: (anyValue: CreateValue) => Serialized
	/** (internal function) Validate the data. Throws if something is wrong with the data */
	validate: (value: Serialized) => void
	/** Returns the value of the MosType */
	valueOf: (value: Serialized) => Value
	/** Returns a stringified representation of the MosType */
	stringify: (value: Serialized) => string
	/** Returns true if the provided data is of this MosType */
	is: (value: Serialized | any) => value is Serialized

	/** Returns a fallback value, used to replace missing or non-parsable data in non-strict mode */
	fallback: () => Serialized
}
‚ãÆ----
/** Creates a MosType using provided data. The MosType is then used in data sent into MOS-connection  */
‚ãÆ----
/** (internal function) Validate the data. Throws if something is wrong with the data */
‚ãÆ----
/** Returns the value of the MosType */
‚ãÆ----
/** Returns a stringified representation of the MosType */
‚ãÆ----
/** Returns true if the provided data is of this MosType */
‚ãÆ----
/** Returns a fallback value, used to replace missing or non-parsable data in non-strict mode */
‚ãÆ----
interface InternalMosType<Serialized, Value> {
	create: (anyValue: any, strict: boolean) => Serialized
	validate: (value: Serialized, strict: boolean) => void
	valueOf(value: Serialized): Value
	stringify(value: Serialized): string
	is(value: Serialized | any): value is Serialized
	fallback(): Serialized
}
‚ãÆ----
valueOf(value: Serialized): Value
stringify(value: Serialized): string
is(value: Serialized | any): value is Serialized
fallback(): Serialized
‚ãÆ----
function getMosType<Serialized, Value, CreateValue>(
	mosType: InternalMosType<Serialized, Value>,
	strict: boolean
): MosType<Serialized, Value, CreateValue>
‚ãÆ----
export interface IMOSExternalMetaData {
	MosScope?: IMOSScope
	MosSchema: string
	MosPayload: AnyXMLValue
}
export enum IMOSScope {
	OBJECT = 'OBJECT',
	STORY = 'STORY',
	PLAYLIST = 'PLAYLIST',
}

================
File: packages/quick-mos/src/convertFromSofieSnapshot.ts
================
import { getMosTypes, IMOSROFullStory, IMOSROStory, IMOSRunningOrder } from '@mos-connection/model'
‚ãÆ----
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
‚ãÆ----
export function convertFromSofieSnapshot(
	filePath: string,
	snapShotData: any
):
‚ãÆ----
function fixStoryBody(stories: any[])

================
File: packages/helper/src/mosModel/lib.ts
================
import { AnyXMLValue } from '@mos-connection/model'
‚ãÆ----
export function isEmpty(obj: unknown): boolean
‚ãÆ----
/** Return true if the object has a property */
export function has(obj: unknown, property: string): boolean
‚ãÆ----
/**
 * Asserts that a string type is of a certain literal.
 * Example usage: const str = assertStringLiteral('foo', ['foo', 'bar']) // str is of type 'foo' | 'bar'
 */
export function assertStringLiteral<T extends string>(value: string, options: T[]): value is T
‚ãÆ----
/** Type assertion */
export function literal<T>(o: T): T
‚ãÆ----
/**
 * Removes undefined properties from an object
 */
export function omitUndefined(obj:
export function flattenXMLText(xml: AnyXMLValue, strict: boolean): string
function flattenXMLTextInner(strings: string[], xml: AnyXMLValue, strict: boolean): void
‚ãÆ----
// else

================
File: .github/workflows/node.yaml
================
name: Node CI - Lint and Test

on:
  push:
    branches:
      - '**'
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+*'
  pull_request:

jobs:
  lint:
    name: Lint and Type check
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16'
      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-modules-${{ hashFiles('**/yarn.lock') }}

      - name: Prepare Environment
        run: yarn
        env:
          CI: true
      - name: Type check
        run: yarn build
        env:
          CI: true
      - name: Lint
        run: |
          yarn lint
        env:
          CI: true

  test:
    name: Test on node ${{ matrix.node_version }} and ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        node_version: ['14', '16', '18', '20']
        os: [ubuntu-latest] # [windows-latest, macOS-latest]

    timeout-minutes: 5
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js ${{ matrix.node_version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node_version }}
      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-modules-${{ hashFiles('**/yarn.lock') }}

      - name: Prepare Environment
        run: |
          yarn
          yarn build
        env:
          CI: true
      - name: Run unit tests
        run: |
          yarn test -- --maxWorkers=2 --forceExit --coverage
        env:
          CI: true
      - name: Send coverage
        uses: codecov/codecov-action@v5
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  validate-dependencies:
    name: Validate production dependencies
    runs-on: ubuntu-latest
    continue-on-error: false
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Use Node.js 16
        uses: actions/setup-node@v4
        with:
          node-version: 16
      - name: Prepare Environment
        run: |
          yarn install
        env:
          CI: true
      - name: Validate dependencies
        run: |
          yarn validate:dependencies
        env:
          CI: true

  release:
    name: Release
    runs-on: ubuntu-latest
    timeout-minutes: 5

    # only run for tags
    if: contains(github.ref, 'refs/tags/')

    needs:
      - test
      - lint

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
      - name: Use Node.js 16
        uses: actions/setup-node@v4
        with:
          node-version: 16
      - name: Check release is desired
        id: do-publish
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "No Token"
          else
            cd packages/connector
            PACKAGE_NAME=@mos-connection/connector
            PUBLISHED_VERSION=$(yarn npm info --json $PACKAGE_NAME | jq -c '.version' -r)
            THIS_VERSION=$(node -p "require('./package.json').version")
            # Simple bash helper to comapre version numbers
            verlte() {
              [  "$1" = "`echo -e "$1\n$2" | sort -V | head -n1`" ]
            }
            verlt() {
              [ "$1" = "$2" ] && return 1 || verlte $1 $2
            }
            if verlt $PUBLISHED_VERSION $THIS_VERSION
            then
              echo "Publishing latest"
              echo "tag=latest" >> $GITHUB_OUTPUT
            else
              echo "Publishing hotfix"
              echo "tag=hotfix" >> $GITHUB_OUTPUT
            fi

          fi
      - name: Prepare Environment
        if: ${{ steps.do-publish.outputs.tag }}
        run: |
          yarn install
        env:
          CI: true
      - name: Build
        if: ${{ steps.do-publish.outputs.tag }}
        run: |
          yarn build
        env:
          CI: true
      - name: Publish to NPM
        if: ${{ steps.do-publish.outputs.tag }}
        run: |
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" >> ~/.npmrc
          yarn lerna publish from-package --tag-version-prefix='' --dist-tag ${{ steps.do-publish.outputs.tag }} --yes --no-verify-access
        env:
          CI: true

================
File: packages/helper/src/mosModel/profile0/xmlConversion.ts
================
import {
	AnyXMLValue,
	IMOSDefaultActiveX,
	IMOSListMachInfo,
	IMOSListMachInfoDefaultActiveXMode,
	IMOSString128,
} from '@mos-connection/model'
import { has, omitUndefined } from '../lib'
import { ensureArray, ensureStringLiteral, ensureXMLObject } from '../../utils/ensureMethods'
import { addTextElementInternal } from '../../utils/Utils'
import { getParseMosTypes, getXMLAttributes } from '../parseMosTypes'
import { XMLMosExternalMetaData } from '../profile1'
import { ParseError } from '../ParseError'
‚ãÆ----
/* eslint-disable @typescript-eslint/no-namespace */
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSString128[]
‚ãÆ----
/* eslint-disable @typescript-eslint/no-namespace */
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSListMachInfo
export function toXML(xmlListMachInfo: XMLBuilder.XMLElement, info: IMOSListMachInfo, strict: boolean): void
‚ãÆ----
export function fromXML(
		path: string,
		xmlSupportedProfiles: AnyXMLValue,
		strict: boolean
): IMOSListMachInfo['supportedProfiles']
‚ãÆ----
// Note: .profiles are added below
‚ãÆ----
// @ts-expect-error hack
‚ãÆ----
export function toXML(
		xml: XMLBuilder.XMLElement,
		supportedProfiles: IMOSListMachInfo['supportedProfiles'],
		strict: boolean
): void
‚ãÆ----
// let p = addTextElement(root, 'supportedProfiles').att('deviceType', info.supportedProfiles.deviceType)
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSDefaultActiveX[]
export function toXML(xml: XMLBuilder.XMLElement, objs: IMOSDefaultActiveX[], strict: boolean): void

================
File: packages/helper/src/mosModel/profile1/xmlConversion.ts
================
import {
	IMOSObject,
	IMOSAck,
	IMOSAckStatus,
	IMOSObjectPath,
	IMOSObjectPathType,
	IMOSExternalMetaData,
	AnyXMLValue,
	AnyXMLValueSingular,
	IMOSObjectType,
	IMOSObjectStatus,
	IMOSObjectAirStatus,
	IMOSScope,
} from '@mos-connection/model'
import { AnyXMLObject, flattenXMLText, has, isEmpty, literal, omitUndefined } from '../lib'
import { ensureArray, ensureXMLObject, ensureXMLObjectArray, isXMLObject } from '../../utils/ensureMethods'
import { addTextElementInternal } from '../../utils/Utils'
import { getParseMosTypes } from '../parseMosTypes'
import { ParseError } from '../ParseError'
‚ãÆ----
/* eslint-disable @typescript-eslint/no-namespace */
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSAck
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSObject[]
export function toXML(xml: XMLBuilder.XMLElement, objs: IMOSObject[], strict: boolean): void
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSObject
export function toXML(xml: XMLBuilder.XMLElement, obj: IMOSObject, strict: boolean): void
‚ãÆ----
if (obj.Description) addTextElementInternal(xml, 'description', obj.Description, undefined, strict) // not handled (todo)
‚ãÆ----
export function fromXML(path: string, xmlObjPaths: AnyXMLValue, strict: boolean): IMOSObjectPath[]
‚ãÆ----
const xmlToArray = (obj: AnyXMLValue): IMOSObjectPath[] =>
‚ãÆ----
// Possible inputs:
/*
				Single obj path
					{
						objPath: '41cfc641849c417eaa10e4f3c377f181',
						techDescription: 'VIDEO'
					}

					{
						objPath: {
							text: '41cfc641849c417eaa10e4f3c377f181',
							techDescription: 'VIDEO'
						},
						objProxyPath: {
							text: 'http://server/proxy/clipe.wmv',
							techDescription: 'WM9 750Kbps'
						}
					}

					{
						objPath: { attributes: { techDescription: 'asdfasdf' }, text: 'asdfasdf' },
						objMetadataPath: { attributes: { techDescription: 'skdjhfb' }, text: '8372h4fv' }
					}
					{
						objPath: [
							{
								'$name': 'objPath',
								'$type': 'text',
								text: '41cfc641849c417eaa10e4f3c377f181',
								techDescription: 'VIDEO'
							},
							{
								'$name': 'objPath',
								'$type': 'text',
								text: 'abc123.mp4',
								techDescription: 'MYVIDEO'
							}
						],
						objProxyPath: {
							'$name': 'objProxyPath',
							'$type': 'text',
							text: 'http://server/proxy/clipe.wmv',
							techDescription: 'WM9 750Kbps'
						}
					}
				*/
‚ãÆ----
// When there is only one: -------------------------------------------
‚ãÆ----
// A single objPath
‚ãÆ----
// A single objProxyPath
‚ãÆ----
// A single objMetadataPath
‚ãÆ----
// When there are multiple: -------------------------------------------
‚ãÆ----
export function toXML(xmlItem: XMLBuilder.XMLElement, paths: IMOSObjectPath[] | undefined, strict: boolean): void
‚ãÆ----
export function fromXML(path: string, xml: AnyXMLValue, strict: boolean): IMOSExternalMetaData[]
‚ãÆ----
export function toXML(xml: XMLBuilder.XMLElement, metadatas: IMOSExternalMetaData[]): void
‚ãÆ----
/** Replace any empty objects with "" */
function fixXMLMosPayload(value: AnyXMLValueSingular): AnyXMLValueSingular
function fixXMLMosPayload(value: AnyXMLObject): AnyXMLObject
function fixXMLMosPayload(value: AnyXMLValue): AnyXMLValue
‚ãÆ----
if (isEmpty(value)) return '' // In xml, an empty tag results in an empty object

================
File: packages/helper/src/mosModel/parseMosTypes.ts
================
import { MosTypes, getMosTypes, MosType, AnyXMLObject } from '@mos-connection/model'
import { AnyXMLValue } from './lib'
import { ParseError } from './ParseError'
import { ensureSingular } from '../utils/ensureMethods'
‚ãÆ----
export function getParseMosTypes(strict: boolean): MosParseTypes
export type MosParseTypes = {
	[key in keyof MosTypes]: MosTypes[key] extends MosType<infer Serialized, infer Value, infer CreateValue>
		? MosTypeParse<Serialized, Value, CreateValue | AnyXMLValue>
		: MosTypes[key]
} & {
	string: MosTypeParse<string, string, AnyXMLValue>
	stringEnum: MosTypeParse<any, string, { enum: { [key: string]: string }; value: AnyXMLValue }>
	number: MosTypeParse<number, number, AnyXMLValue>
}
interface MosTypeParse<Serialized, Value, CreateValue> extends Omit<MosType<Serialized, Value, CreateValue>, 'create'> {
	/**
	 * Used to parse data that is optional.
	 * If the data is missing, undefined is returned.
	 */
	createOptional: (anyValue: CreateValue, path: string) => Serialized | undefined
	/**
	 * Used to parse data that is required.
	 * If in strict mode, the data must be present and parsable, otherwise an error is thrown.
	 * If not in strict mode, a fallback value will be used.
	 */
	createRequired: (anyValue: CreateValue, path: string) => Serialized
}
‚ãÆ----
/**
	 * Used to parse data that is optional.
	 * If the data is missing, undefined is returned.
	 */
‚ãÆ----
/**
	 * Used to parse data that is required.
	 * If in strict mode, the data must be present and parsable, otherwise an error is thrown.
	 * If not in strict mode, a fallback value will be used.
	 */
‚ãÆ----
function wrapParseMethods<Serialized, Value, CreateValue>(
	mosType: MosType<Serialized, Value, CreateValue>,
	valueIsSingular: boolean,
	strict: boolean
): MosTypeParse<Serialized, Value, CreateValue | AnyXMLValue>
function wrapParseMethodCreateOptional<Serialized, Value, CreateValue>(
	mosType: MosType<Serialized, Value, CreateValue>,
	valueIsSingular: boolean,
	strict: boolean
): MosTypeParse<Serialized, Value, CreateValue | AnyXMLValue>['createOptional']
function wrapParseMethodCreateRequired<Serialized, Value, CreateValue>(
	mosType: MosType<Serialized, Value, CreateValue>,
	valueIsSingular: boolean,
	strict: boolean
): MosTypeParse<Serialized, Value, CreateValue | AnyXMLValue>['createRequired']
‚ãÆ----
export function parseOptional<V, R>(
	parser: (value: V) => R,
	valueIsSingular: boolean,
	strict: boolean
): (value: V | AnyXMLValue, path: string) => R | undefined
‚ãÆ----
// handle empty string:
‚ãÆ----
// handle empty object (can happen when parsing an empty xml tag):
‚ãÆ----
export function parseRequired<V, R>(
	parser: (value: V) => R,
	fallback: () => R,
	valueIsSingular: boolean,
	strict: boolean
): (value: V | AnyXMLValue, path: string) => R
‚ãÆ----
// handle empty string:
‚ãÆ----
// handle empty object (can happen when parsing an empty xml tag):
‚ãÆ----
// Something might be wrong. value is undefined, but should not be (?)
‚ãÆ----
// This will throw if the mosType doesn't handle undefined:
‚ãÆ----
function getSpecialMosTypes(strict: boolean)
export function getXMLAttributes(obj: AnyXMLObject):

================
File: packages/model/src/mosTypes/mosDuration.ts
================
import { pad } from './lib'
‚ãÆ----
export interface IMOSDuration {
	_mosDuration: number // in seconds
	/** @deprecated use getMosTypes().mosDuration.stringify() instead! */
	toString: never
}
‚ãÆ----
_mosDuration: number // in seconds
/** @deprecated use getMosTypes().mosDuration.stringify() instead! */
‚ãÆ----
export function create(anyValue: AnyValue, strict: boolean): IMOSDuration
‚ãÆ----
value = anyValue // seconds
‚ãÆ----
export type AnyValue = string | number | IMOSDuration
export function validate(_mosDuration: IMOSDuration, _strict: boolean): void
‚ãÆ----
// nothing
‚ãÆ----
export function valueOf(mosDuration: IMOSDuration): number
‚ãÆ----
if (typeof mosDuration === 'number') return mosDuration // helpful hack
‚ãÆ----
export function stringify(mosDuration: IMOSDuration): string
‚ãÆ----
if (typeof mosDuration === 'string') return mosDuration // helpful hack
‚ãÆ----
export function is(mosDuration: IMOSDuration | any): mosDuration is IMOSDuration
export function fallback(): IMOSDuration

================
File: packages/quick-mos/src/index.ts
================
/* eslint-disable node/no-unpublished-import */
‚ãÆ----
import {
	MosConnection,
	IMOSRunningOrder,
	IMOSROStory,
	IMOSROFullStory,
	IConnectionConfig,
	IMOSDeviceConnectionOptions,
	MosDevice,
	IMOSListMachInfo,
	IMOSObjectAirStatus,
	getMosTypes,
} from '@mos-connection/connector'
import { diffLists, ListEntry, OperationType } from './mosDiff'
‚ãÆ----
import { convertFromSofieSnapshot } from './convertFromSofieSnapshot'
‚ãÆ----
const DELAY_TIME = 300 // ms
‚ãÆ----
export interface Config {
	mosConnection: IConnectionConfig
	devices: IMOSDeviceConnectionOptions[]
}
‚ãÆ----
// @ts-expect-error just a stub, will be overwritten by /input/config.ts
‚ãÆ----
function triggerReload()
function loadFile(requirePath: string): any
‚ãÆ----
// eslint-disable-next-line @typescript-eslint/no-var-requires
‚ãÆ----
async function reloadInner()
‚ãÆ----
// Save the new config:
‚ãÆ----
// Kill the old:
‚ãÆ----
// Set up the new:
‚ãÆ----
// opTime?: MosTime;
‚ãÆ----
// profile3?: boolean;
// profile4?: boolean;
// profile5?: boolean;
// profile6?: boolean;
// profile7?: boolean;
‚ãÆ----
// defaultActiveX?: Array<IMOSDefaultActiveX>;
// 	mosExternalMetaData?: Array<IMOSExternalMetaData>;
‚ãÆ----
// mosDevice.onRequestMOSObject((objId: string) => Promise<IMOSObject | null>): void;
// mosDevice.onRequestAllMOSObjects((pause: number) => Promise<Array<IMOSObject> | IMOSAck>): void;
// mosDevice.onCreateRunningOrder((ro: IMOSRunningOrder) => Promise<IMOSROAck>): void;
// mosDevice.onReplaceRunningOrder((ro: IMOSRunningOrder) => Promise<IMOSROAck>): void;
// mosDevice.onDeleteRunningOrder((runningOrderId: MosString128) => Promise<IMOSROAck>): void;
// mosDevice.onRequestRunningOrder((runningOrderId: MosString128) => Promise<IMOSRunningOrder | null>): void;
// mosDevice.onMetadataReplace((metadata: IMOSRunningOrderBase) => Promise<IMOSROAck>): void;
// mosDevice.onRunningOrderStatus((status: IMOSRunningOrderStatus) => Promise<IMOSROAck>): void;
// mosDevice.onStoryStatus((status: IMOSStoryStatus) => Promise<IMOSROAck>): void;
// mosDevice.onItemStatus((status: IMOSItemStatus) => Promise<IMOSROAck>): void;
// mosDevice.onReadyToAir((Action: IMOSROReadyToAir) => Promise<IMOSROAck>): void;
// mosDevice.onROInsertStories((Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>): void;
// mosDevice.onROInsertItems((Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>): void;
// mosDevice.onROReplaceStories((Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>): void;
// mosDevice.onROReplaceItems((Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>): void;
// mosDevice.onROMoveStories((Action: IMOSStoryAction, Stories: Array<MosString128>) => Promise<IMOSROAck>): void;
// mosDevice.onROMoveItems((Action: IMOSItemAction, Items: Array<MosString128>) => Promise<IMOSROAck>): void;
// mosDevice.onRODeleteStories((Action: IMOSROAction, Stories: Array<MosString128>) => Promise<IMOSROAck>): void;
// mosDevice.onRODeleteItems((Action: IMOSStoryAction, Items: Array<MosString128>) => Promise<IMOSROAck>): void;
// mosDevice.onROSwapStories((Action: IMOSROAction, StoryID0: MosString128, StoryID1: MosString128) => Promise<IMOSROAck>): void;
// mosDevice.onROSwapItems((Action: IMOSStoryAction, ItemID0: MosString128, ItemID1: MosString128) => Promise<IMOSROAck>): void;
// mosDevice.onMosObjCreate((object: IMOSObject) => Promise<IMOSAck>): void;
// mosDevice.onMosItemReplace((roID: MosString128, storyID: MosString128, item: IMOSItem) => Promise<IMOSROAck>): void;
// mosDevice.onMosReqSearchableSchema((username: string) => Promise<IMOSSearchableSchema>): void;
// mosDevice.onMosReqObjectList((objList: IMosRequestObjectList) => Promise<IMosObjectList>): void;
// mosDevice.onMosReqObjectAction((action: string, obj: IMOSObject) => Promise<IMOSAck>): void;
‚ãÆ----
// mosDevice.onROStory((story: IMOSROFullStory) => Promise<IMOSROAck>): void;
‚ãÆ----
function refreshFiles()
‚ãÆ----
// Check data
‚ãÆ----
function fetchRunningOrders()
‚ãÆ----
requirePath.match(/[/\\]_/) || // ignore and folders files that begin with "_"
requirePath.match(/[/\\]lib\.ts/) // ignore lib files
‚ãÆ----
// Is a Sofie snapshot
‚ãÆ----
function getAllFilesInDirectory(dir: string): string[]
‚ãÆ----
// ------------
‚ãÆ----
type MOSCommand = () => Promise<any>
class MOSMonitor
‚ãÆ----
constructor(private mosDevice: MosDevice)
‚ãÆ----
setTimeout(() => this.triggerRandomUpdate(), 10000) // startup delay
‚ãÆ----
triggerRandomUpdate()
‚ãÆ----
// only fire if the queue is sufficiently small (to avoid a backlog)
‚ãÆ----
// send it
‚ãÆ----
// run again
setTimeout(() => this.triggerRandomUpdate(), 500) // abritrary gap
‚ãÆ----
// run again
setTimeout(() => this.triggerRandomUpdate(), 10000) // abritrary gap
‚ãÆ----
onDeletedRunningOrder(roId: string)
‚ãÆ----
// At the end, store the updated RO:
‚ãÆ----
resendRunningOrder(roId: string): IMOSRunningOrder
onUpdatedRunningOrder(ro: IMOSRunningOrder, fullStories: IMOSROFullStory[], readyToAir: boolean | undefined): void
‚ãÆ----
// compare with
‚ãÆ----
// New RO
‚ãÆ----
// nothing changed, do nothing
‚ãÆ----
// Only RO metadata has changed
‚ãÆ----
// Only Stories has changed
‚ãÆ----
/*
				// const addedGroups = this.groupIndexes(o.added)
				_.each(o.added, (stories, beforeId) => {
					// const index = parseInt(index0, 10)
				})
				_.each(o.changed, c => {
					this.commands.push(() => {
						console.log('sendROReplaceStories', ro.ID)
						const story = ro.Stories[c.id]
						return this.mosDevice.sendROReplaceStories({
							RunningOrderID: ro.ID,
							StoryID: mosTypes.mosString128.create(c.id)
						}, [ c.story ])
					})
				})
				// Swap logic:
				// if (
				// 	o.moved.length === 2 &&
				// 	o.moved[0].ids.length === 1 &&
				// 	o.moved[1].ids.length === 1 &&

				// 	o.moved[0].beforeId

				// 	o.moved[0].beforeId === o.moved[1].oldIndex &&
				// 	o.moved[1].index === o.moved[0].oldIndex
				// ) {
				// 	this.commands.push(() => {
				// 		console.log('sendROSwapStories', ro.ID)
				// 		return this.mosDevice.sendROSwapStories({
				// 			RunningOrderID: ro.ID
				// 		},
				// 		mosTypes.mosString128.create(o.moved[0].id),
				// 		mosTypes.mosString128.create(o.moved[1].id)
				// 		)
				// 	})
				// } else {
				// const movedGroups = this.groupIndexes(o.moved)
				// console.log('movedGroups', movedGroups)
				_.each(o.moved, (m) => {
					// const index = parseInt(index0, 10)
					this.commands.push(() => {
						console.log('sendROMoveStories', ro.ID, m.afterId, m.ids)
						// const behindStory = index > 0 && ro.Stories[index - 1]
						return this.mosDevice.sendROMoveStories({
							RunningOrderID: ro.ID,
							StoryID: mosTypes.mosString128.create(m.afterId)
						}, m.ids.map(m => mosTypes.mosString128.create(m)))
					})
				})
				*/
‚ãÆ----
// last resort: replace the whole rundown
‚ãÆ----
// At the end, store the updated RO:
‚ãÆ----
groupIndexes<T extends
static prepareStories(stories: IMOSROStory[]): ListEntry<IMOSROStory>[]
static md5(str: string): string
‚ãÆ----
private triggerCheckQueue()
‚ãÆ----
this.commands.splice(0, 1) // remove the command from queue, as it has now been executed successfully
‚ãÆ----
function fakeOnUpdatedRunningOrder(ro: IMOSRunningOrder, _fullStories: IMOSROFullStory[]): void
‚ãÆ----
// compare with
‚ãÆ----
// console.log('fakeOnUpdatedRunningOrder', roId)
‚ãÆ----
// New RO
‚ãÆ----
// console.log(_.omit(localRo.ro,	'MosExternalMetaData', 'Stories'))
// console.log(_.omit(ro,		'MosExternalMetaData', 'Stories'))
// console.log(metadataEqual)
// console.log(roStoriesEqual)
// console.log(roBaseDataEqual)
‚ãÆ----
// nothing changed, do nothing
‚ãÆ----
// Only RO metadata has changed
‚ãÆ----
// this.commands.push(() => {
// 	return this.mosDevice.sendMetadataReplace(ro)
// })
‚ãÆ----
// Only Stories has changed
‚ãÆ----
// const inserts = operation.inserts.map((i) => i.content)
‚ãÆ----
// this.commands.push(() => {
// 	return this.mosDevice.sendROInsertStories({
// 		RunningOrderID: ro.ID,
// 		StoryID: mosTypes.mosString128.create(operation.beforeId)
// 	}, inserts)
// })
‚ãÆ----
// const updatedStory = operation.content
‚ãÆ----
// this.commands.push(() => {
// 	return this.mosDevice.sendROReplaceStories({
// 		RunningOrderID: ro.ID,
// 		StoryID: mosTypes.mosString128.create(operation.id)
// 	}, [ updatedStory ])
// })
‚ãÆ----
// this.commands.push(() => {
// 	return this.mosDevice.sendRODeleteStories({
// 		RunningOrderID: ro.ID
// 	}, removeIds.map(id => mosTypes.mosString128.create(id)))
// })
‚ãÆ----
// this.commands.push(() => {
// 	return this.mosDevice.sendROMoveStories({
// 		RunningOrderID: ro.ID,
// 		StoryID: mosTypes.mosString128.create(beforeId)
// 	}, moveIds.map(id => mosTypes.mosString128.create(id)))
// })
‚ãÆ----
// last resort: replace the whole rundown
‚ãÆ----
// this.commands.push(() => {
// 	return this.mosDevice.sendReplaceRunningOrder(ro)
// })
‚ãÆ----
// At the end, store the updated RO:
‚ãÆ----
// this.triggerCheckQueue()

================
File: packages/connector/src/api.ts
================
import {
	IProfiles,
	IMOSListMachInfo,
	IMOSObject,
	MosItemReplaceOptions,
	IMOSListSearchableSchema,
	IMOSRequestObjectList,
	IMOSObjectList,
	IMOSAck,
	IMOSRunningOrder,
	IMOSItem,
	IMOSItemAction,
	IMOSItemStatus,
	IMOSROAck,
	IMOSROAction,
	IMOSROFullStory,
	IMOSROReadyToAir,
	IMOSROStory,
	IMOSRunningOrderBase,
	IMOSRunningOrderStatus,
	IMOSStoryAction,
	IMOSStoryStatus,
	IMOSString128,
} from '@mos-connection/model'
import { MosDevice } from './MosDevice'
‚ãÆ----
/*
	This file defines the API for the MOS-connection.
	Most of these interfaces are derived from the MOS protocol.
	https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm
*/
export interface IMosConnection {
	readonly isListening: boolean

	readonly acceptsConnections: boolean
	readonly profiles: IProfiles
	readonly isCompliant: boolean
	readonly complianceText: string

	dispose: () => Promise<void>
	/*  */
	connect: (connectionOptions: IMOSDeviceConnectionOptions) => Promise<MosDevice> // resolved when connection has been made (before .onConnection is fired)
	onConnection: (cb: (mosDevice: MosDevice) => void) => void

	on(event: 'error', listener: (error: Error) => void): this
	on(event: 'warning', listener: (message: string) => void): this
	on(event: 'info', listener: (message: string, data?: any) => void): this
	on(event: 'rawMessage', listener: (source: string, type: string, message: string) => void): this
}
‚ãÆ----
/*  */
connect: (connectionOptions: IMOSDeviceConnectionOptions) => Promise<MosDevice> // resolved when connection has been made (before .onConnection is fired)
‚ãÆ----
on(event: 'error', listener: (error: Error)
on(event: 'warning', listener: (message: string)
on(event: 'info', listener: (message: string, data?: any)
on(event: 'rawMessage', listener: (source: string, type: string, message: string)
‚ãÆ----
export interface IMOSDevice
	extends IMOSDeviceProfile0,
		IMOSDeviceProfile1,
		IMOSDeviceProfile2,
		IMOSDeviceProfile3,
		IMOSDeviceProfile4 {
	idPrimary: string // unique id for this device and session
	idSecondary: string | null // unique id for this device and session (buddy)
}
‚ãÆ----
idPrimary: string // unique id for this device and session
idSecondary: string | null // unique id for this device and session (buddy)
‚ãÆ----
/**
 * Method definitions for Profile 1
 * see https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#Profile1
 */
export interface IMOSDeviceProfile0 {
	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * The reqMachInfo message is a method for an NCS or MOS to determine more information about its counterpart.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#reqMachInfo
	 */
	requestMachineInfo: () => Promise<IMOSListMachInfo>
	/**
	 * Send message (as NCS) to a MOS device:
	 * The reqMachInfo message is a method for an NCS or MOS to determine more information about its counterpart.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#reqMachInfo
	 */
	onRequestMachineInfo: (cb: () => Promise<IMOSListMachInfo>) => void

	/** Assign callback for when the connection status changes. */
	onConnectionChange: (cb: (connectionStatus: IMOSConnectionStatus) => void) => void
	/** Get the current connection status */
	getConnectionStatus: () => IMOSConnectionStatus

	// Deprecated methods:
	/** @deprecated getMachineInfo is deprecated, use requestMachineInfo instead */
	getMachineInfo: () => Promise<IMOSListMachInfo>
	/** @deprecated onGetMachineInfo is deprecated, use onRequestMachineInfo instead */
	onGetMachineInfo: (cb: () => Promise<IMOSListMachInfo>) => void
}
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * The reqMachInfo message is a method for an NCS or MOS to determine more information about its counterpart.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#reqMachInfo
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * The reqMachInfo message is a method for an NCS or MOS to determine more information about its counterpart.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#reqMachInfo
	 */
‚ãÆ----
/** Assign callback for when the connection status changes. */
‚ãÆ----
/** Get the current connection status */
‚ãÆ----
// Deprecated methods:
/** @deprecated getMachineInfo is deprecated, use requestMachineInfo instead */
‚ãÆ----
/** @deprecated onGetMachineInfo is deprecated, use onRequestMachineInfo instead */
‚ãÆ----
/**
 * Method definitions for Profile 1
 * see https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#Profile1
 */
export interface IMOSDeviceProfile1 {
	/**
	 * Contains information that describes a unique MOS Object to the NCS.
	 * The NCS uses this information to search for and reference the MOS Object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObj
	 */
	sendMOSObject(obj: IMOSObject): Promise<IMOSAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Message used by the NCS to request the description of an object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObj
	 */
	onRequestMOSObject: (cb: (objId: string) => Promise<IMOSObject | null>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Message used by the NCS to request the description of an object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObj
	 */
	sendRequestMOSObject: (objId: IMOSString128) => Promise<IMOSObject>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Contains information that describes a unique MOS Object to the NCS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObj
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosListAll
	 */
	onMOSObjects: (cb: (objs: IMOSObject[]) => Promise<IMOSAck>) => void

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Method for the NCS to request the MOS to send it a mosObj message for every Object in the MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqAll
	 */
	onRequestAllMOSObjects: (cb: () => Promise<Array<IMOSObject>>) => void
	/**
	 * Method for the NCS to request the MOS to send it a mosObj message for every Object in the MOS.
	 * The replies will be sent to the callback set up in onMOSObjects()
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqAll
	 */
	sendRequestAllMOSObjects: (
		/**
		 * Pause, when greater than zero, indicates the number of seconds to pause between individual mosObj messages.
		 * Pause of zero indicates that all objects will be sent using the mosListAll message.
		 * @default 0
		 */
		pause?: number
	) => Promise<IMOSAck>

	// Deprecated methods:
	/** @deprecated getMOSObject is deprecated, use sendRequestMOSObject instead */
	getMOSObject: (objId: IMOSString128) => Promise<IMOSObject>
	/** @deprecated getAllMOSObjects is deprecated, use sendRequestAllMOSObjects instead */
	getAllMOSObjects: () => Promise<IMOSAck>
}
‚ãÆ----
/**
	 * Contains information that describes a unique MOS Object to the NCS.
	 * The NCS uses this information to search for and reference the MOS Object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObj
	 */
sendMOSObject(obj: IMOSObject): Promise<IMOSAck>
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Message used by the NCS to request the description of an object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObj
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Message used by the NCS to request the description of an object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObj
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Contains information that describes a unique MOS Object to the NCS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObj
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosListAll
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Method for the NCS to request the MOS to send it a mosObj message for every Object in the MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqAll
	 */
‚ãÆ----
/**
	 * Method for the NCS to request the MOS to send it a mosObj message for every Object in the MOS.
	 * The replies will be sent to the callback set up in onMOSObjects()
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqAll
	 */
‚ãÆ----
/**
		 * Pause, when greater than zero, indicates the number of seconds to pause between individual mosObj messages.
		 * Pause of zero indicates that all objects will be sent using the mosListAll message.
		 * @default 0
		 */
‚ãÆ----
// Deprecated methods:
/** @deprecated getMOSObject is deprecated, use sendRequestMOSObject instead */
‚ãÆ----
/** @deprecated getAllMOSObjects is deprecated, use sendRequestAllMOSObjects instead */
‚ãÆ----
/**
 * Method definitions for Profile 2
 * see https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#Profile2
 */
export interface IMOSDeviceProfile2 {
	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Message received from the NCS to the MOS that defines a new Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roCreate
	 */
	onCreateRunningOrder: (cb: (ro: IMOSRunningOrder) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Message from the NCS to the MOS that defines a new Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roCreate
	 */
	sendCreateRunningOrder: (ro: IMOSRunningOrder) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Message received from the NCS to the MOS that defines a new Running Order, replacing an existing one.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReplace
	 */
	onReplaceRunningOrder: (cb: (ro: IMOSRunningOrder) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Message received from the NCS to the MOS that defines a new Running Order, replacing an existing one.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReplace
	 */
	sendReplaceRunningOrder: (ro: IMOSRunningOrder) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Deletes a Running order in the MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roDelete
	 */
	onDeleteRunningOrder: (cb: (runningOrderId: IMOSString128) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Deletes a Running order in the MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roDelete
	 */
	sendDeleteRunningOrder: (runningOrderId: IMOSString128) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Request for a complete build of a Running Order Playlist. NOTE:  This message can be used by either NCS or MOS.
	 * A MOS can use this to "resync" its Playlist with the NCS Running Order or to obtain a full description of the Playlist at any time.
	 * An NCS can use this as a diagnostic tool to check the order of the Playlist constructed in the MOS versus the sequence of Items in the Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReq
	 * Response: https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roList
	 */
	onRequestRunningOrder: (cb: (runningOrderId: IMOSString128) => Promise<IMOSRunningOrder | null>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Request for a complete build of a Running Order Playlist. NOTE:  This message can be used by either NCS or MOS.
	 * A MOS can use this to "resync" its Playlist with the NCS Running Order or to obtain a full description of the Playlist at any time.
	 * An NCS can use this as a diagnostic tool to check the order of the Playlist constructed in the MOS versus the sequence of Items in the Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReq
	 * Response: https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roList
	 */
	sendRequestRunningOrder: (runningOrderId: IMOSString128) => Promise<IMOSRunningOrder | null>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * The roMetadataReplace message allows metadata associated with a running order to be replaced without deleting the running order and sending the entire running order again.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roMetadataReplace
	 */
	onMetadataReplace: (cb: (metadata: IMOSRunningOrderBase) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * The roMetadataReplace message allows metadata associated with a running order to be replaced without deleting the running order and sending the entire running order again.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roMetadataReplace
	 */
	sendMetadataReplace: (metadata: IMOSRunningOrderBase) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * A method for the MOS to update the NCS on the status of a RO. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
	onRunningOrderStatus: (cb: (status: IMOSRunningOrderStatus) => Promise<IMOSROAck>) => void // get roElementStat
	/**
	 * Send message (as NCS) to a MOS device:
	 * A method for the MOS to update the NCS on the status of a RO. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
	sendRunningOrderStatus: (status: IMOSRunningOrderStatus) => Promise<IMOSROAck> // send roElementStat

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * A method for the MOS to update the NCS on the status of a STORY. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
	onStoryStatus: (cb: (status: IMOSStoryStatus) => Promise<IMOSROAck>) => void // get roElementStat
	/**
	 * Send message (as NCS) to a MOS device:
	 * A method for the MOS to update the NCS on the status of a STORY. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
	sendStoryStatus: (status: IMOSStoryStatus) => Promise<IMOSROAck> // send roElementStat

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * A method for the MOS to update the NCS on the status of an ITEM. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
	onItemStatus: (cb: (status: IMOSItemStatus) => Promise<IMOSROAck>) => void // get roElementStat
	/**
	 * Send message (as NCS) to a MOS device:
	 * A method for the MOS to update the NCS on the status of an ITEM. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
	sendItemStatus: (status: IMOSItemStatus) => Promise<IMOSROAck> // send roElementStat

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * The roReadyToAir message allows the NCS to signal the MOS that a Running Order has been editorially approved ready for air.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReadyToAir
	 */
	onReadyToAir: (cb: (Action: IMOSROReadyToAir) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * The roReadyToAir message allows the NCS to signal the MOS that a Running Order has been editorially approved ready for air.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReadyToAir
	 */
	sendReadyToAir: (Action: IMOSROReadyToAir) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Insert one or more story into a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROInsertStories: (cb: (Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Insert one or more story into a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROInsertStories: (Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Insert one or more Items into a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROInsertItems: (cb: (Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Insert one or more Items into a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROInsertItems: (Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Replace (update) a Story with a new story.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROReplaceStories: (cb: (Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Replace (update) a Story with a new story.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROReplaceStories: (Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Replace (update) an Item with a new Item.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROReplaceItems: (cb: (Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Replace (update) an Item with a new Item.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROReplaceItems: (Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Move one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROMoveStories: (cb: (Action: IMOSStoryAction, Stories: Array<IMOSString128>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Move one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROMoveStories: (Action: IMOSStoryAction, Stories: Array<IMOSString128>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Move one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROMoveItems: (cb: (Action: IMOSItemAction, Items: Array<IMOSString128>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Move one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROMoveItems: (Action: IMOSItemAction, Items: Array<IMOSString128>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Delete one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onRODeleteStories: (cb: (Action: IMOSROAction, Stories: Array<IMOSString128>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Delete one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendRODeleteStories: (Action: IMOSROAction, Stories: Array<IMOSString128>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Delete one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onRODeleteItems: (cb: (Action: IMOSStoryAction, Items: Array<IMOSString128>) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Delete one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendRODeleteItems: (Action: IMOSStoryAction, Items: Array<IMOSString128>) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Swap two Stories
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROSwapStories: (
		cb: (Action: IMOSROAction, StoryID0: IMOSString128, StoryID1: IMOSString128) => Promise<IMOSROAck>
	) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Swap two Stories
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROSwapStories: (Action: IMOSROAction, StoryID0: IMOSString128, StoryID1: IMOSString128) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Swap two Items
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	onROSwapItems: (
		cb: (Action: IMOSStoryAction, ItemID0: IMOSString128, ItemID1: IMOSString128) => Promise<IMOSROAck>
	) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * Swap two Items
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
	sendROSwapItems: (Action: IMOSStoryAction, ItemID0: IMOSString128, ItemID1: IMOSString128) => Promise<IMOSROAck>

	// Deprecated methods:
	/** @deprecated getRunningOrder is deprecated, use sendRequestRunningOrder instead */
	getRunningOrder: (runningOrderId: IMOSString128) => Promise<IMOSRunningOrder | null>
	/** @deprecated setRunningOrderStatus is deprecated, use sendRunningOrderStatus instead */
	setRunningOrderStatus: (status: IMOSRunningOrderStatus) => Promise<IMOSROAck>
	/** @deprecated setStoryStatus is deprecated, use sendStoryStatus instead */
	setStoryStatus: (status: IMOSStoryStatus) => Promise<IMOSROAck>
	/** @deprecated setItemStatus is deprecated, use sendItemStatus instead */
	setItemStatus: (status: IMOSItemStatus) => Promise<IMOSROAck>
}
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Message received from the NCS to the MOS that defines a new Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roCreate
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Message from the NCS to the MOS that defines a new Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roCreate
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Message received from the NCS to the MOS that defines a new Running Order, replacing an existing one.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReplace
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Message received from the NCS to the MOS that defines a new Running Order, replacing an existing one.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReplace
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Deletes a Running order in the MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roDelete
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Deletes a Running order in the MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roDelete
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Request for a complete build of a Running Order Playlist. NOTE:  This message can be used by either NCS or MOS.
	 * A MOS can use this to "resync" its Playlist with the NCS Running Order or to obtain a full description of the Playlist at any time.
	 * An NCS can use this as a diagnostic tool to check the order of the Playlist constructed in the MOS versus the sequence of Items in the Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReq
	 * Response: https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roList
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Request for a complete build of a Running Order Playlist. NOTE:  This message can be used by either NCS or MOS.
	 * A MOS can use this to "resync" its Playlist with the NCS Running Order or to obtain a full description of the Playlist at any time.
	 * An NCS can use this as a diagnostic tool to check the order of the Playlist constructed in the MOS versus the sequence of Items in the Running Order.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReq
	 * Response: https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roList
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * The roMetadataReplace message allows metadata associated with a running order to be replaced without deleting the running order and sending the entire running order again.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roMetadataReplace
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * The roMetadataReplace message allows metadata associated with a running order to be replaced without deleting the running order and sending the entire running order again.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roMetadataReplace
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * A method for the MOS to update the NCS on the status of a RO. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
onRunningOrderStatus: (cb: (status: IMOSRunningOrderStatus) => Promise<IMOSROAck>) => void // get roElementStat
/**
	 * Send message (as NCS) to a MOS device:
	 * A method for the MOS to update the NCS on the status of a RO. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
sendRunningOrderStatus: (status: IMOSRunningOrderStatus) => Promise<IMOSROAck> // send roElementStat
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * A method for the MOS to update the NCS on the status of a STORY. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
onStoryStatus: (cb: (status: IMOSStoryStatus) => Promise<IMOSROAck>) => void // get roElementStat
/**
	 * Send message (as NCS) to a MOS device:
	 * A method for the MOS to update the NCS on the status of a STORY. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
sendStoryStatus: (status: IMOSStoryStatus) => Promise<IMOSROAck> // send roElementStat
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * A method for the MOS to update the NCS on the status of an ITEM. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
onItemStatus: (cb: (status: IMOSItemStatus) => Promise<IMOSROAck>) => void // get roElementStat
/**
	 * Send message (as NCS) to a MOS device:
	 * A method for the MOS to update the NCS on the status of an ITEM. This allows the NCS to reflect the status of any element in the MOS Running Order in the NCS Running Order display.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.7.2_roElementStat_-
	 */
sendItemStatus: (status: IMOSItemStatus) => Promise<IMOSROAck> // send roElementStat
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * The roReadyToAir message allows the NCS to signal the MOS that a Running Order has been editorially approved ready for air.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReadyToAir
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * The roReadyToAir message allows the NCS to signal the MOS that a Running Order has been editorially approved ready for air.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReadyToAir
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Insert one or more story into a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Insert one or more story into a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Insert one or more Items into a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Insert one or more Items into a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Replace (update) a Story with a new story.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Replace (update) a Story with a new story.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Replace (update) an Item with a new Item.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Replace (update) an Item with a new Item.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Move one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Move one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Move one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Move one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Delete one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Delete one or more Stories within a Running Order
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Delete one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Delete one or more Items within a Story
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Swap two Stories
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Swap two Stories
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * Swap two Items
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * Swap two Items
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roElementAction
	 */
‚ãÆ----
// Deprecated methods:
/** @deprecated getRunningOrder is deprecated, use sendRequestRunningOrder instead */
‚ãÆ----
/** @deprecated setRunningOrderStatus is deprecated, use sendRunningOrderStatus instead */
‚ãÆ----
/** @deprecated setStoryStatus is deprecated, use sendStoryStatus instead */
‚ãÆ----
/** @deprecated setItemStatus is deprecated, use sendItemStatus instead */
‚ãÆ----
/**
 * Method definitions for Profile 3
 * see https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#Profile3
 */
export interface IMOSDeviceProfile3 {
	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosObjCreate allows an NCS to request the Media Object Server to create a Media Object with specific metadata associated with it.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObjCreate
	 */
	onObjectCreate: (cb: (object: IMOSObject) => Promise<IMOSAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * mosObjCreate allows an NCS to request the Media Object Server to create a Media Object with specific metadata associated with it.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObjCreate
	 */
	sendObjectCreate: (object: IMOSObject) => Promise<IMOSAck>

	/**
	 * Assign callback (as a NCS device) for when receiving message from MOS:
	 * This message allows a Media Object Server to replace an Item Reference in a Story with new metadata values and/or additional tags.
	 * The Story must be in a MOS Active PlayList.
	 * This message is initiated by the Media Object Server, rather than the NCS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosItemReplace
	 */
	onItemReplace: (cb: (roID: IMOSString128, storyID: IMOSString128, item: IMOSItem) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as MOS) to a NCS:
	 * This message allows a Media Object Server to replace an Item Reference in a Story with new metadata values and/or additional tags.
	 * The Story must be in a MOS Active PlayList.
	 * This message is initiated by the Media Object Server, rather than the NCS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosItemReplace
	 */
	sendItemReplace: (options: MosItemReplaceOptions) => Promise<IMOSROAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqSearchable Schema is a mechanism used by the NCS to request the MOS to send a pointer to a schema in which searchable fields are defined by the MOS device.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqSearchableSchema
	 */
	onRequestSearchableSchema: (cb: (username: string) => Promise<IMOSListSearchableSchema>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqSearchable Schema is a mechanism used by the NCS to request the MOS to send a pointer to a schema in which searchable fields are defined by the MOS device.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqSearchableSchema
	 */
	sendRequestSearchableSchema: (username: string) => Promise<IMOSListSearchableSchema>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjList is a mechanism used by a NCS to retrieve only selected object descriptions from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObjList
	 */
	onRequestObjectList: (cb: (objList: IMOSRequestObjectList) => Promise<IMOSObjectList>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjList is a mechanism used by a NCS to retrieve only selected object descriptions from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObjList
	 */
	sendRequestObjectList: (reqObjList: IMOSRequestObjectList) => Promise<IMOSObjectList>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
	onRequestObjectActionNew: (cb: (obj: IMOSObject) => Promise<IMOSAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
	sendRequestObjectActionNew: (obj: IMOSObject) => Promise<IMOSAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
	onRequestObjectActionUpdate: (cb: (objId: IMOSString128, obj: IMOSObject) => Promise<IMOSAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
	sendRequestObjectActionUpdate: (objId: IMOSString128, obj: IMOSObject) => Promise<IMOSAck>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
	onRequestObjectActionDelete: (cb: (objId: IMOSString128) => Promise<IMOSAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
	sendRequestObjectActionDelete: (objId: IMOSString128) => Promise<IMOSAck>

	// Deprecated methods:
	/** @deprecated onMosObjCreate is deprecated, use onObjectCreate instead */
	onMosObjCreate: (cb: (object: IMOSObject) => Promise<IMOSAck>) => void
	/** @deprecated mosObjCreate is deprecated, use sendObjectCreate instead */
	mosObjCreate: (object: IMOSObject) => Promise<IMOSAck>
	/** @deprecated onMosItemReplace is deprecated, use onItemReplace instead */
	onMosItemReplace: (cb: (roID: IMOSString128, storyID: IMOSString128, item: IMOSItem) => Promise<IMOSROAck>) => void
	/** @deprecated mosItemReplace is deprecated, use sendItemReplace instead */
	mosItemReplace: (options: MosItemReplaceOptions) => Promise<IMOSROAck>
	/** @deprecated onMosReqSearchableSchema is deprecated, use onRequestSearchableSchema instead */
	onMosReqSearchableSchema: (cb: (username: string) => Promise<IMOSListSearchableSchema>) => void
	/** @deprecated mosRequestSearchableSchema is deprecated, use sendRequestSearchableSchema instead */
	mosRequestSearchableSchema: (username: string) => Promise<IMOSListSearchableSchema>
	/** @deprecated onMosReqObjectList is deprecated, use onRequestObjectList instead */
	onMosReqObjectList: (cb: (objList: IMOSRequestObjectList) => Promise<IMOSObjectList>) => void
	/** @deprecated mosRequestObjectList is deprecated, use sendRequestObjectList instead */
	mosRequestObjectList: (reqObjList: IMOSRequestObjectList) => Promise<IMOSObjectList>
	/** @deprecated onMosReqObjectAction is deprecated, use onRequestObjectAction*** instead */
	onMosReqObjectAction: (cb: (action: string, obj: IMOSObject) => Promise<IMOSAck>) => void
}
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosObjCreate allows an NCS to request the Media Object Server to create a Media Object with specific metadata associated with it.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObjCreate
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * mosObjCreate allows an NCS to request the Media Object Server to create a Media Object with specific metadata associated with it.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosObjCreate
	 */
‚ãÆ----
/**
	 * Assign callback (as a NCS device) for when receiving message from MOS:
	 * This message allows a Media Object Server to replace an Item Reference in a Story with new metadata values and/or additional tags.
	 * The Story must be in a MOS Active PlayList.
	 * This message is initiated by the Media Object Server, rather than the NCS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosItemReplace
	 */
‚ãÆ----
/**
	 * Send message (as MOS) to a NCS:
	 * This message allows a Media Object Server to replace an Item Reference in a Story with new metadata values and/or additional tags.
	 * The Story must be in a MOS Active PlayList.
	 * This message is initiated by the Media Object Server, rather than the NCS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosItemReplace
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqSearchable Schema is a mechanism used by the NCS to request the MOS to send a pointer to a schema in which searchable fields are defined by the MOS device.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqSearchableSchema
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqSearchable Schema is a mechanism used by the NCS to request the MOS to send a pointer to a schema in which searchable fields are defined by the MOS device.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqSearchableSchema
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjList is a mechanism used by a NCS to retrieve only selected object descriptions from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObjList
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjList is a mechanism used by a NCS to retrieve only selected object descriptions from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqObjList
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * mosReqObjAction allows an NCS to request the Media Object Server to create, modify or delete a media object.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#_3.3.3_mosReqObjAction_%E2%80%93_NCS_request
	 */
‚ãÆ----
// Deprecated methods:
/** @deprecated onMosObjCreate is deprecated, use onObjectCreate instead */
‚ãÆ----
/** @deprecated mosObjCreate is deprecated, use sendObjectCreate instead */
‚ãÆ----
/** @deprecated onMosItemReplace is deprecated, use onItemReplace instead */
‚ãÆ----
/** @deprecated mosItemReplace is deprecated, use sendItemReplace instead */
‚ãÆ----
/** @deprecated onMosReqSearchableSchema is deprecated, use onRequestSearchableSchema instead */
‚ãÆ----
/** @deprecated mosRequestSearchableSchema is deprecated, use sendRequestSearchableSchema instead */
‚ãÆ----
/** @deprecated onMosReqObjectList is deprecated, use onRequestObjectList instead */
‚ãÆ----
/** @deprecated mosRequestObjectList is deprecated, use sendRequestObjectList instead */
‚ãÆ----
/** @deprecated onMosReqObjectAction is deprecated, use onRequestObjectAction*** instead */
‚ãÆ----
/**
 * Method definitions for Profile 4
 * see https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#Profile4
 */
export interface IMOSDeviceProfile4 {
	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * roReqAll is a request for a description of all Running Orders known by a NCS from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReqAll
	 */
	onRequestAllRunningOrders: (cb: () => Promise<IMOSRunningOrder[]>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * roReqAll is a request for a description of all Running Orders known by a NCS from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReqAll
	 */
	sendRequestAllRunningOrders: () => Promise<Array<IMOSRunningOrderBase>>

	/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * This message enables sending the body of story from the NCS to a Media Object Server.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roStorySend
	 */
	onRunningOrderStory: (cb: (story: IMOSROFullStory) => Promise<IMOSROAck>) => void
	/**
	 * Send message (as NCS) to a MOS device:
	 * This message enables sending the body of story from the NCS to a Media Object Server.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roStorySend
	 */
	sendRunningOrderStory: (story: IMOSROFullStory) => Promise<IMOSROAck>

	// Deprecated methods:
	/** @deprecated onROReqAll is deprecated, use onRequestAllRunningOrders instead */
	onROReqAll: (cb: () => Promise<IMOSRunningOrder[]>) => void
	/** @deprecated getAllRunningOrders is deprecated, use sendRequestAllRunningOrders instead */
	getAllRunningOrders: () => Promise<Array<IMOSRunningOrderBase>> // send roReqAll
	/** @deprecated onROStory is deprecated, use onRunningOrderStory instead */
	onROStory: (cb: (story: IMOSROFullStory) => Promise<IMOSROAck>) => void // roStorySend
	/** @deprecated sendROStory is deprecated, use sendRunningOrderStory instead */
	sendROStory: (story: IMOSROFullStory) => Promise<IMOSROAck> // roStorySend
}
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * roReqAll is a request for a description of all Running Orders known by a NCS from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReqAll
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * roReqAll is a request for a description of all Running Orders known by a NCS from a MOS.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roReqAll
	 */
‚ãÆ----
/**
	 * Assign callback (as a MOS device) for when receiving message from NCS:
	 * This message enables sending the body of story from the NCS to a Media Object Server.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roStorySend
	 */
‚ãÆ----
/**
	 * Send message (as NCS) to a MOS device:
	 * This message enables sending the body of story from the NCS to a Media Object Server.
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#roStorySend
	 */
‚ãÆ----
// Deprecated methods:
/** @deprecated onROReqAll is deprecated, use onRequestAllRunningOrders instead */
‚ãÆ----
/** @deprecated getAllRunningOrders is deprecated, use sendRequestAllRunningOrders instead */
getAllRunningOrders: () => Promise<Array<IMOSRunningOrderBase>> // send roReqAll
/** @deprecated onROStory is deprecated, use onRunningOrderStory instead */
onROStory: (cb: (story: IMOSROFullStory) => Promise<IMOSROAck>) => void // roStorySend
/** @deprecated sendROStory is deprecated, use sendRunningOrderStory instead */
sendROStory: (story: IMOSROFullStory) => Promise<IMOSROAck> // roStorySend
‚ãÆ----
// /** */
export interface IMOSConnectionStatus {
	PrimaryConnected: boolean
	PrimaryStatus: string // if not connected this will contain human-readable error-message
	SecondaryConnected: boolean
	SecondaryStatus: string // if not connected this will contain human-readable error-message
}
‚ãÆ----
PrimaryStatus: string // if not connected this will contain human-readable error-message
‚ãÆ----
SecondaryStatus: string // if not connected this will contain human-readable error-message
‚ãÆ----
/** Config object for creating a MOS-device */
export interface IConnectionConfig {
	/** The ID of this mos-device */
	mosID: string
	/** Whether this mosConnection accepts new connections from othe MOS clients (ie acts as an NCS) */
	acceptsConnections: boolean
	/** Only accept connections from this whitelist */
	accepsConnectionsFrom?: string[]
	/** A list of which profile this mos device is to support */
	profiles: IProfiles
	/** If true, this device is assumed to be an NCS (server). Defaults to a MOS (client). */
	isNCS?: boolean
	/** Debugging-mode: logs raw mos-messages */
	debug?: boolean
	offspecFailover?: boolean
	/** If set to true, a strict check is performed to ensure that all required callbacks are set up for specified profiles */
	strict?: boolean
	/** If set, overrides the standard port numbers */
	ports?: {
		/** Set MOS Lower port (standard: 10540) */
		lower: number
		/** Set MOS Upper port (standard: 10541) */
		upper: number
		/** Set MOS Query port (standard: 10542) */
		query: number
	}
	/** When enabled, automatically create new mos-devices on-the-fly when receiving messages to unregistered MOS-ID:s */
	openRelay?:
		| boolean
		| {
				// options for on-the-fly-created connections
				options: IMOSDeviceConnectionOptions['primary']
		  }
}
‚ãÆ----
/** The ID of this mos-device */
‚ãÆ----
/** Whether this mosConnection accepts new connections from othe MOS clients (ie acts as an NCS) */
‚ãÆ----
/** Only accept connections from this whitelist */
‚ãÆ----
/** A list of which profile this mos device is to support */
‚ãÆ----
/** If true, this device is assumed to be an NCS (server). Defaults to a MOS (client). */
‚ãÆ----
/** Debugging-mode: logs raw mos-messages */
‚ãÆ----
/** If set to true, a strict check is performed to ensure that all required callbacks are set up for specified profiles */
‚ãÆ----
/** If set, overrides the standard port numbers */
‚ãÆ----
/** Set MOS Lower port (standard: 10540) */
‚ãÆ----
/** Set MOS Upper port (standard: 10541) */
‚ãÆ----
/** Set MOS Query port (standard: 10542) */
‚ãÆ----
/** When enabled, automatically create new mos-devices on-the-fly when receiving messages to unregistered MOS-ID:s */
‚ãÆ----
// options for on-the-fly-created connections
‚ãÆ----
export interface IMOSDeviceConnectionOptions {
	/** Connection options for the Primary NCS-server */
	primary: {
		/** Name (NCS ID) of the NCS-server */
		id: string
		/** Host address (IP-address) of the NCS-server  */
		host: string // ip-addr
		/** (Optional): Custom ports for communication */
		ports?: {
			upper: number
			lower: number
			query: number
		}
		/** (Optional) Timeout for commands (ms) */
		timeout?: number
		/** (Optional) Interval for sending of hearbeats (ms) */
		heartbeatInterval?: number
		/** (Optional) Some server doesn't expose the Query port, which can cause connection-errors.
		 * Set this to true to not use that port (will cause some methods to stop working)
		 */
		dontUseQueryPort?: boolean
	}
	/** Connection options for the Secondary (Buddy) NCS-server */
	secondary?: {
		/** Name (NCS ID) of the Buddy NCS-server */
		id: string
		/** Host address (IP-address) of the NCS-server  */
		host: string
		/** (Optional): Custom ports for communication */
		ports?: {
			upper: number
			lower: number
			query: number
		}
		/** (Optional) Timeout for commands (ms) */
		timeout?: number
		/** (Optional) Interval for sending of hearbeats (ms) */
		heartbeatInterval?: number

		/** (Optional) Some server doesn't expose the Query port, which can cause connection-errors.
		 * Set this to true to not use that port (will cause some methods to stop working)
		 */
		dontUseQueryPort?: boolean

		/** (Optional) Treat the secondary server as a "hot standby".
		 * A "hot standby" is a server that is powered down / in standby while the primary server is up.
		 * When a server is a hot standby it is expected to be disconnected and hence we will not send
		 * heartbeat messages. The connection status will still be reported as disconnected however as we
		 * do not pretend to be connected to something that is powered down.
		 *
		 * (This was added to support the hot standby feature of OpenMedia NRCS.)
		 */
		openMediaHotStandby?: boolean
	}
}
‚ãÆ----
/** Connection options for the Primary NCS-server */
‚ãÆ----
/** Name (NCS ID) of the NCS-server */
‚ãÆ----
/** Host address (IP-address) of the NCS-server  */
host: string // ip-addr
/** (Optional): Custom ports for communication */
‚ãÆ----
/** (Optional) Timeout for commands (ms) */
‚ãÆ----
/** (Optional) Interval for sending of hearbeats (ms) */
‚ãÆ----
/** (Optional) Some server doesn't expose the Query port, which can cause connection-errors.
		 * Set this to true to not use that port (will cause some methods to stop working)
		 */
‚ãÆ----
/** Connection options for the Secondary (Buddy) NCS-server */
‚ãÆ----
/** Name (NCS ID) of the Buddy NCS-server */
‚ãÆ----
/** Host address (IP-address) of the NCS-server  */
‚ãÆ----
/** (Optional): Custom ports for communication */
‚ãÆ----
/** (Optional) Timeout for commands (ms) */
‚ãÆ----
/** (Optional) Interval for sending of hearbeats (ms) */
‚ãÆ----
/** (Optional) Some server doesn't expose the Query port, which can cause connection-errors.
		 * Set this to true to not use that port (will cause some methods to stop working)
		 */
‚ãÆ----
/** (Optional) Treat the secondary server as a "hot standby".
		 * A "hot standby" is a server that is powered down / in standby while the primary server is up.
		 * When a server is a hot standby it is expected to be disconnected and hence we will not send
		 * heartbeat messages. The connection status will still be reported as disconnected however as we
		 * do not pretend to be connected to something that is powered down.
		 *
		 * (This was added to support the hot standby feature of OpenMedia NRCS.)
		 */

================
File: packages/model/src/mosTypes/mosTime.ts
================
import { pad } from './lib'
‚ãÆ----
export interface IMOSTime {
	_mosTime: number
	_timezone: string
	_timezoneOffset: number

	/** @deprecated use getMosTypes().mosTime.stringify() instead! */
	toString: never
}
‚ãÆ----
/** @deprecated use getMosTypes().mosTime.stringify() instead! */
‚ãÆ----
export function create(timestamp: AnyValue, strict: boolean): IMOSTime
‚ãÆ----
// let value: number
‚ãÆ----
// create date from time-string or timestamp number
‚ãÆ----
// formats:
// YYYY-MM-DD'T'hh:mm:ss[,ddd]['Z']
// Sun Feb 25 2018 08:59:08 GMT+0100 (CET)
// 2018-02-25T08:00:45.528Z
‚ãÆ----
// parse out custom Z indicator (mos-centric)
‚ãÆ----
// parse out custom timezones (mos local-local centric format)
‚ãÆ----
// try to parse the time directly with Date, for Date-supported formats
‚ãÆ----
export type AnyValue = Date | number | string | IMOSTime
‚ãÆ----
export function validate(_mosDuration: IMOSTime, _strict: boolean): void
‚ãÆ----
// nothing
‚ãÆ----
export function valueOf(mosTime: IMOSTime): number
‚ãÆ----
if (typeof mosTime === 'number') return mosTime // helpful hack
‚ãÆ----
export function stringify(mosTime: IMOSTime): string
‚ãÆ----
if (typeof mosTime === 'string') return mosTime // helpful hack
‚ãÆ----
// Cheat a little bit to get the time-zone right:
// First add the local offset to get the Date to display the time in UTC,
// then add the timezoneOffset to get the time in the the correct time-zone:
‚ãÆ----
export function is(mosTime: IMOSTime | any): mosTime is IMOSTime
export function fallback(): IMOSTime
‚ãÆ----
function parseTimeOffset(timestamp: string): false |
‚ãÆ----
/** */
function parseMosCustomFormat(timestamp: string):
	| false
	| {
			yy: string
			mm: string
			dd: string
			hh: string
			ii: string
			ss: string
			ms: string
			timezoneIndicator: string
			/** in minutes */
			timezoneOffset: number
	  } {
	const timestampRegex = /(\d+)-(\d+)-(\d+)T(\d+):(\d+):(\d+)([,.](\d{3}))?(([+-Z])([:\d]+)?)?/i
	const match = timestamp.match(timestampRegex)
if (match)
‚ãÆ----
/** in minutes */
‚ãÆ----
const m = timezoneIndicator.match(/([+-])(\d+):(\d+)/) // +5:00,  -05:00

================
File: packages/examples/package.json
================
{
	"name": "mos-examples",
	"private": true,
	"version": "0.0.0",
	"description": "Examples for how to use MOS-connection",
	"main": "dist/index.js",
	"typings": "dist/index.d.ts",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/nrkno/sofie-mos-connection.git"
	},
	"homepage": "https://github.com/nrkno/sofie-mos-connection#readme",
	"scripts": {
		"build": "run -T rimraf dist && run build:main",
		"build:main": "run -T tsc -p tsconfig.build.json",
		"__test": "run -T jest",
		"validate:dependencies": "yarn npm audit --environment production && yarn license-validate",
		"validate:dev-dependencies": "yarn npm audit ",
		"license-validate": "yarn sofie-licensecheck"
	},
	"engines": {
		"node": ">=14.18.0"
	},
	"dependencies": {
		"@mos-connection/connector": "4.2.2"
	},
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"lint-staged": {
		"*.{css,json,md,scss}": [
			"run -T prettier"
		],
		"*.{ts,tsx,js,jsx}": [
			"run -T eslint"
		]
	},
	"files": [
		"/dist",
		"/CHANGELOG.md",
		"/README.md",
		"/LICENSE"
	],
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "*",
		"typescript": "~4.9.5"
	}
}

================
File: packages/helper/package.json
================
{
	"name": "@mos-connection/helper",
	"version": "4.2.2",
	"description": "Helper functions for the MOS-connection library",
	"main": "dist/index.js",
	"typings": "dist/index.d.ts",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/nrkno/sofie-mos-connection.git"
	},
	"bugs": {
		"url": "https://github.com/nrkno/sofie-mos-connection/issues"
	},
	"homepage": "https://github.com/nrkno/sofie-mos-connection#readme",
	"scripts": {
		"build": "run -T rimraf dist && run build:main",
		"build:main": "run -T tsc -p tsconfig.build.json",
		"test": "run -T jest",
		"test:coverage": "yarn test --coverage",
		"validate:dependencies": "yarn npm audit --environment production && yarn license-validate",
		"validate:dev-dependencies": "yarn npm audit ",
		"license-validate": "yarn sofie-licensecheck"
	},
	"files": [
		"/dist",
		"/CHANGELOG.md",
		"/README.md",
		"/LICENSE"
	],
	"dependencies": {
		"@mos-connection/model": "4.2.2",
		"iconv-lite": "^0.6.3",
		"tslib": "^2.5.3",
		"xml-js": "^1.6.11",
		"xmlbuilder": "^15.1.1"
	},
	"keywords": [
		"mos",
		"broadcast",
		"socket",
		"typescript",
		"javascript",
		"open",
		"source",
		"automation",
		"ncs",
		"nrcs",
		"rundown",
		"tv-production",
		"sofie"
	],
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"engines": {
		"node": ">=14.18.0"
	},
	"lint-staged": {
		"*.{css,json,md,scss}": [
			"run -T prettier"
		],
		"*.{ts,tsx,js,jsx}": [
			"run -T eslint"
		]
	},
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "*",
		"typescript": "~4.9.5"
	}
}

================
File: packages/model/package.json
================
{
	"name": "@mos-connection/model",
	"version": "4.2.2",
	"description": "Types and enums for the mos-connection library",
	"main": "dist/index.js",
	"typings": "dist/index.d.ts",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/nrkno/sofie-mos-connection.git"
	},
	"homepage": "https://github.com/nrkno/sofie-mos-connection#readme",
	"scripts": {
		"build": "run -T rimraf dist && run build:main",
		"build:main": "run -T tsc -p tsconfig.build.json",
		"test": "run -T jest",
		"test:coverage": "yarn test --coverage",
		"validate:dependencies": "yarn npm audit --environment production && yarn license-validate",
		"validate:dev-dependencies": "yarn npm audit ",
		"license-validate": "yarn sofie-licensecheck"
	},
	"engines": {
		"node": ">=14.18.0"
	},
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"lint-staged": {
		"*.{css,json,md,scss}": [
			"run -T prettier"
		],
		"*.{ts,tsx,js,jsx}": [
			"run -T eslint"
		]
	},
	"files": [
		"/dist",
		"/CHANGELOG.md",
		"/README.md",
		"/LICENSE"
	],
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "*",
		"typescript": "~4.9.5"
	}
}

================
File: lerna.json
================
{
  "packages": [
    "packages/*"
  ],
  "version": "4.2.2",
  "npmClient": "yarn",
  "useWorkspaces": true
}

================
File: packages/connector/src/connection/mosSocketClient.ts
================
import { EventEmitter } from 'eventemitter3'
import { Socket } from 'net'
import { SocketConnectionEvent } from './socketConnection'
import { MosModel } from '@mos-connection/helper'
import { DEFAULT_COMMAND_TIMEOUT, HandedOverQueue } from './NCSServerConnection'
‚ãÆ----
import { ParsedMosMessage, MosMessageParser } from './mosMessageParser'
‚ãÆ----
export type CallBackFunction = (data: { error: Error | string } | { reply: ParsedMosMessage }) => void
‚ãÆ----
export interface QueueMessage {
	time: number
	msg: MosModel.MosMessage
}
‚ãÆ----
export interface MosSocketClientEvents {
	[SocketConnectionEvent.CONNECTED]: () => void
	[SocketConnectionEvent.DISCONNECTED]: () => void
	[SocketConnectionEvent.DISPOSED]: () => void
	[SocketConnectionEvent.ALIVE]: () => void
	// [SocketConnectionEvent.TIMEOUT]: () => void
	// [SocketConnectionEvent.REGISTER]: () => void
	// [SocketConnectionEvent.UNREGISTER]: () => void

	error: (error: Error) => void
	warning: (warning: string) => void
	rawMessage: (...args: any[]) => void
}
‚ãÆ----
// [SocketConnectionEvent.TIMEOUT]: () => void
// [SocketConnectionEvent.REGISTER]: () => void
// [SocketConnectionEvent.UNREGISTER]: () => void
‚ãÆ----
export class MosSocketClient extends EventEmitter<MosSocketClientEvents>
‚ãÆ----
private _lingeringCallback: { [messageId: string]: CallBackFunction } = {} // for lingering messages
‚ãÆ----
private _sentMessage: QueueMessage | null = null // sent message, waiting for reply
‚ãÆ----
private _lingeringMessage: QueueMessage | null = null // sent message, NOT waiting for reply
// private _readyToSendMessage: boolean = true
‚ãÆ----
// private _startingUp: boolean = true
‚ãÆ----
/** */
constructor(host: string, port: number, description: string, timeout: number, debug: boolean, strict: boolean)
‚ãÆ----
/** */
set autoReconnect(autoReconnect: boolean)
‚ãÆ----
/** */
set autoReconnectInterval(autoReconnectInterval: number)
‚ãÆ----
/** */
set autoReconnectAttempts(autoReconnectAttempts: number)
‚ãÆ----
/** */
connect(): void
‚ãÆ----
// prevent manipulation of active socket
‚ãÆ----
// throttling attempts
‚ãÆ----
// !_lastReconnectionAttempt (means first attempt) OR time > _reconnectionDelay since last attempt
// recreate client if new attempt:
‚ãÆ----
// (re)create client, either on first run or new attempt:
‚ãÆ----
// connect:
‚ãÆ----
// set timer to retry when needed:
‚ãÆ----
/** */
disconnect(): void
‚ãÆ----
queueCommand(message: MosModel.MosMessage, cb: CallBackFunction, time?: number): void
‚ãÆ----
// this.debugTrace('queueing', message.messageID, message.constructor.name )
‚ãÆ----
processQueue(): void
‚ãÆ----
// Send the message:
‚ãÆ----
// The queue is empty, do nothing
‚ãÆ----
// Try again later:
‚ãÆ----
/**
	 * Returns a queue of messages to be executed by a different connection.
	 * Will exclude hearbeats from the returned queue. The heartbeats must stay inside
	 * the internal queue because they are needed for the connection lifecycle.
	 */
handOverQueue(): HandedOverQueue
‚ãÆ----
// Temporary hack, to allow heartbeats to be received after a handover:
‚ãÆ----
/** */
get host(): string
‚ãÆ----
/** */
get port(): number
‚ãÆ----
/** */
dispose(): void
‚ãÆ----
// this._readyToSendMessage = false
‚ãÆ----
/**
	 * convenience wrapper to expose all logging calls to parent object
	 */
log(...args: any[]): void
public setDebug(debug: boolean): void
/** */
private set connected(connected: boolean)
‚ãÆ----
/** */
private get connected(): boolean
‚ãÆ----
private _sendReply(messageId: number, response:
‚ãÆ----
// this._onUnhandledCommandTimeout()
‚ãÆ----
/** */
private executeCommand(message: QueueMessage, isRetry?: boolean): void
‚ãÆ----
// Command timeout:
‚ãÆ----
/** */
private _autoReconnectionAttempt(): void
‚ãÆ----
// no reconnection if no valid reconnectionAttemps is set
‚ãÆ----
// if current attempt is not less than max attempts
// reset reconnection behaviour
‚ãÆ----
// new attempt if not allready connected
‚ãÆ----
/** */
private _clearConnectionAttemptTimer(): void
‚ãÆ----
/** */
private _onConnected()
‚ãÆ----
/** */
private _onData(data: Buffer)
‚ãÆ----
private _handleMessage(parsedData: ParsedMosMessage, messageString: string)
‚ãÆ----
// huh, we've got a reply to something we've not sent.
‚ãÆ----
// error message?
‚ãÆ----
// unknown message..
‚ãÆ----
// this._readyToSendMessage = true
‚ãÆ----
private _getMessageId(parsedData: ParsedMosMessage, messageString: string): string | undefined
‚ãÆ----
// If there is a messageID:
‚ãÆ----
// In non-strict mode: handle special cases:
‚ãÆ----
// <heartbeat> response doesn't contain messageId (compliant with MOS version 2.8)
// we can assume it's the same as our sent message:
‚ãÆ----
// <reqMachInfo> response doesn't contain messageId (compliant with MOS version 2.8)
// we can assume it's the same as our sent message:
‚ãÆ----
/** */
private _onError(error: Error)
‚ãÆ----
// dispatch error!!!!!
‚ãÆ----
/** */
private _onClose(hadError: boolean)
‚ãÆ----
// this._readyToSendMessage = false
‚ãÆ----
private _triggerQueueCleanup()
‚ãÆ----
// in case we're in unsync with messages, prevent deadlock:
‚ãÆ----
private debugTrace(...args: any[])
‚ãÆ----
// eslint-disable-next-line no-console

================
File: packages/connector/package.json
================
{
	"name": "@mos-connection/connector",
	"version": "4.2.2",
	"description": "MOS compliant TCP/IP Socket connection.",
	"main": "dist/index.js",
	"typings": "dist/index.d.ts",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/nrkno/sofie-mos-connection.git"
	},
	"bugs": {
		"url": "https://github.com/nrkno/sofie-mos-connection/issues"
	},
	"homepage": "https://github.com/nrkno/sofie-mos-connection#readme",
	"scripts": {
		"build": "run -T rimraf dist && run build:main",
		"build:main": "run -T tsc -p tsconfig.build.json",
		"test": "run -T jest",
		"test:coverage": "yarn test --coverage",
		"validate:dependencies": "yarn npm audit --environment production && yarn license-validate",
		"validate:dev-dependencies": "yarn npm audit ",
		"license-validate": "yarn sofie-licensecheck"
	},
	"files": [
		"/dist",
		"/CHANGELOG.md",
		"/README.md",
		"/LICENSE"
	],
	"dependencies": {
		"@mos-connection/helper": "4.2.2",
		"@mos-connection/model": "4.2.2",
		"eventemitter3": "^5.0.1",
		"iconv-lite": "^0.6.3",
		"tslib": "^2.5.3",
		"xml-js": "^1.6.11",
		"xmlbuilder": "^15.1.1"
	},
	"keywords": [
		"mos",
		"broadcast",
		"socket",
		"typescript",
		"javascript",
		"open",
		"source",
		"automation",
		"ncs",
		"nrcs",
		"rundown",
		"tv-production",
		"sofie"
	],
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"engines": {
		"node": ">=14.18.0"
	},
	"lint-staged": {
		"*.{css,json,md,scss}": [
			"run -T prettier"
		],
		"*.{ts,tsx,js,jsx}": [
			"run -T eslint"
		]
	},
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "*",
		"typescript": "~4.9.5"
	}
}

================
File: packages/quick-mos/package.json
================
{
	"name": "quick-mos",
	"version": "0.0.0",
	"private": true,
	"description": "Read rundowns from files, use mos-connection and send mos commands",
	"main": "src/index.ts",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "git+https://github.com/nrkno/sofie-mos-connection.git"
	},
	"homepage": "https://github.com/nrkno/sofie-mos-connection#readme",
	"author": {
		"name": "Johan Nyman",
		"email": "johan@superfly.tv",
		"url": "http://superfly.tv"
	},
	"contributors": [],
	"scripts": {
		"build": "run -T rimraf dist && run build:main",
		"buildstart": "run build && run start",
		"buildinspect": "run build && run inspect",
		"build:main": "run -T tsc -p tsconfig.json",
		"test": "run -T jest",
		"inspect": "node --inspect dist/index.js",
		"start": "ts-node src/index.ts",
		"validate:dependencies": "yarn npm audit --environment production && yarn license-validate",
		"validate:dev-dependencies": "yarn npm audit ",
		"license-validate": "yarn sofie-licensecheck"
	},
	"engines": {
		"node": ">=14.18.0"
	},
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "*",
		"@types/node": "^20.10.5",
		"@types/underscore": "^1.11.5",
		"ts-node": "^10.9.1",
		"typescript": "~4.9.5"
	},
	"dependencies": {
		"@mos-connection/connector": "4.2.2",
		"@mos-connection/model": "4.2.2",
		"chokidar": "^3.5.3",
		"fast-clone": "^1.5.13",
		"tslib": "^2.5.3",
		"underscore": "^1.13.6"
	},
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"lint-staged": {
		"*.{css,json,md,scss}": [
			"run -T prettier"
		],
		"*.{ts,tsx,js,jsx}": [
			"run -T eslint"
		]
	},
	"files": [
		"/dist",
		"/CHANGELOG.md",
		"/README.md",
		"/LICENSE"
	]
}

================
File: packages/connector/src/connection/NCSServerConnection.ts
================
import { ConnectionType } from './socketConnection'
import { MosSocketClient, CallBackFunction, QueueMessage } from '../connection/mosSocketClient'
import { MosModel } from '@mos-connection/helper'
import { EventEmitter } from 'eventemitter3'
import { ParsedMosMessage } from './mosMessageParser'
‚ãÆ----
export interface ClientDescription {
	useHeartbeats: boolean
	heartbeatConnected: boolean
	client: MosSocketClient
	clientDescription: MosModel.PortType
}
‚ãÆ----
export interface INCSServerConnection {
	on(event: 'rawMessage', listener: (type: string, message: string) => void): this
}
‚ãÆ----
on(event: 'rawMessage', listener: (type: string, message: string)
‚ãÆ----
export interface HandedOverQueue {
	messages: QueueMessage[]
	callbacks: { [messageId: string]: CallBackFunction }
}
export interface NCSServerConnectionEvents {
	rawMessage: (...args: any[]) => void
	warning: (str: string) => void
	error: (err: Error) => void
	info: (str: string) => void
	connectionChanged: () => void
}
‚ãÆ----
/** Handles connections to a NCS (server) */
export class NCSServerConnection extends EventEmitter<NCSServerConnectionEvents> implements INCSServerConnection
‚ãÆ----
// private _lastSeen: number
‚ãÆ----
constructor(
		id: string,
		host: string,
		mosID: string,
		timeout: number | undefined,
		heartbeatsInterval: number | undefined,
		debug: boolean,
		strict: boolean
)
get timeout(): number
/** Create a MOS client, which talks to  */
createClient(clientID: string, port: number, clientDescription: ConnectionType, useHeartbeats: boolean): void
‚ãÆ----
/** */
removeClient(clientID: string): void
‚ãÆ----
/** */
disableHeartbeats(): void
‚ãÆ----
/** */
enableHeartbeats(): void
‚ãÆ----
/** */
isHearbeatEnabled(): boolean
‚ãÆ----
setAutoReconnectInterval(interval: number): void
‚ãÆ----
connect(): void
‚ãÆ----
// Connect client
‚ãÆ----
// Send heartbeat and check connection
‚ãÆ----
// Emit to _callbackOnConnectionChange
// if (this._callbackOnConnectionChange) this._callbackOnConnectionChange()
‚ãÆ----
/**
	 * Sends a mos message.
	 * Returns a Promise which resolves when a MOS reply has been received.
	 */
async executeCommand(message: MosModel.MosMessage): Promise<ParsedMosMessage>
‚ãÆ----
// Fill with clients
‚ãÆ----
// Set mosID and ncsID
‚ãÆ----
// Example: Port based on message type
‚ãÆ----
public setDebug(debug: boolean): void
get connected(): boolean
getConnectedStatus():
‚ãÆ----
private _getClients(clientDescription: string): MosSocketClient[]
/** */
get lowerPortClients(): MosSocketClient[]
‚ãÆ----
/** */
get upperPortClients(): MosSocketClient[]
‚ãÆ----
/** */
get queryPortClients(): MosSocketClient[]
get host(): string
get id(): string
‚ãÆ----
handOverQueue(otherConnection: NCSServerConnection): void
‚ãÆ----
// this._clients.forEach((client, id) => {
// 	// cmds[id] = client.client.handOverQueue()
// })
‚ãÆ----
receiveQueue(queue:
‚ãÆ----
// @todo: keep order
// @todo: prevent callback-promise horror...
‚ãÆ----
async dispose(): Promise<void>
‚ãÆ----
private _sendHeartBeats(): void
‚ãÆ----
const triggerNextHeartBeat = () =>
‚ãÆ----
// probably a timeout
‚ãÆ----
private debugTrace(...strs: any[])
‚ãÆ----
// eslint-disable-next-line no-console

================
File: packages/connector/src/MosConnection.ts
================
import { Socket } from 'net'
import { ConnectionConfig } from './config/connectionConfig'
import { MosSocketServer } from './connection/mosSocketServer'
import { getMosTypes, IMOSAckStatus, IProfiles, MosTypes } from '@mos-connection/model'
import { MosDevice } from './MosDevice'
import { SocketServerEvent, SocketDescription, IncomingConnectionType } from './connection/socketConnection'
import { NCSServerConnection } from './connection/NCSServerConnection'
import { MosModel } from '@mos-connection/helper'
import { EventEmitter } from 'eventemitter3'
‚ãÆ----
import { ParsedMosMessage, MosMessageParser } from './connection/mosMessageParser'
import { IConnectionConfig, IMosConnection, IMOSDeviceConnectionOptions } from './api'
import { PROFILE_VALIDNESS_CHECK_WAIT_TIME } from './lib'
‚ãÆ----
export interface MosConnectionEvents {
	// Note: These match the events defined in IMosConnection
	rawMessage: (source: string, type: string, message: string) => void
	info: (message: string, data?: any) => void
	warning: (message: string) => void
	error: (error: Error) => void
}
‚ãÆ----
// Note: These match the events defined in IMosConnection
‚ãÆ----
export class MosConnection extends EventEmitter<MosConnectionEvents> implements IMosConnection
‚ãÆ----
// private _isListening: Promise<boolean[]>
‚ãÆ----
/** */
constructor(configOptions: IConnectionConfig)
‚ãÆ----
// Setup utility functions for handling MosTypes:
‚ãÆ----
/**
	 * Initiate the MosConnection, start accepting connections
	 */
async init(): Promise<boolean>
‚ãÆ----
/**
	 * Establish a new connection to a MOS-device (NCS-server). When established, the new MOS-device will be emitted to this.onConnection()
	 * @param connectionOptions Connection options
	 */
async connect(connectionOptions: IMOSDeviceConnectionOptions): Promise<MosDevice>
‚ãÆ----
// Connect to MOS-device:
‚ãÆ----
// Create the secondary connection if configured
‚ãÆ----
// For hot-standby, initially we need both connections to be able to establish
// so we can determine which one is active
‚ãÆ----
// Check both connections on startup to determine which one to use
‚ãÆ----
// Wait for initial connection attempts
‚ãÆ----
// Handle that .openMediaHotStandby should not check for heartbeats on
// the secondary connection when the primary is connected
// And disable heartbeats on the primary when the primary is disconnected
‚ãÆ----
// Initially disable heartbeats on secondary since primary is connected
‚ãÆ----
// Primary is down, but secondary is available - use secondary
‚ãÆ----
// Both are down initially, but try both
‚ãÆ----
// Failover handling:
‚ãÆ----
// Refresh connectionstatus
‚ãÆ----
// Primary disconnected, enable secondary heartbeats
‚ãÆ----
// Refresh connectionstatus
‚ãÆ----
// Secondary is active when primary is down
‚ãÆ----
// Both are down, try to connect to both
‚ãÆ----
/** Callback is called when a new connection is established */
onConnection(cb: (mosDevice: MosDevice) => void): void
/** True if mosConnection is listening for connections */
get isListening(): boolean
‚ãÆ----
/** TO BE IMPLEMENTED: True if mosConnection is mos-compliant */
get isCompliant(): boolean
‚ãÆ----
/** True if mosConnection is configured to accept connections */
get acceptsConnections(): boolean
‚ãÆ----
/** A list of the profiles mosConnection is currently configured to use */
get profiles(): IProfiles
‚ãÆ----
/** Close all connections and clear all data */
async dispose(): Promise<void>
/** Return a specific MOS-device */
getDevice(id: string): MosDevice
/** Get a list of all MOS-devices */
getDevices(): Array<MosDevice>
disposeMosDevice(mosDevice: MosDevice): Promise<void>
disposeMosDevice(myMosID: string, theirMosId0: string, theirMosId1: string | null): Promise<void>
async disposeMosDevice(
		myMosIDOrMosDevice: string | MosDevice,
		theirMosId0?: string,
		theirMosId1?: string | null
): Promise<void>
‚ãÆ----
// myMosID = myMosIDOrMosDevice
‚ãÆ----
/**
	 * Do a check if the profile is valid. Throws if not.
	 * Optionally called after a mosConnection has been set up to ensure that all callbacks have been set up properly.
	 */
checkProfileValidness(): void
‚ãÆ----
/** TO BE IMPLEMENTED */
get complianceText(): string
public setDebug(debug: boolean): void
private _registerMosDevice(
		myMosID: string,
		theirMosId0: string,
		theirMosId1: string | null,
		primary: NCSServerConnection | null,
		secondary: NCSServerConnection | null
): MosDevice
‚ãÆ----
// Add mosDevice to register:
‚ãÆ----
// emit to .onConnection:
‚ãÆ----
/** Set up TCP-server */
private async _initiateIncomingConnections(): Promise<void>
‚ãÆ----
const initSocket = (port: number, portType: IncomingConnectionType) =>
‚ãÆ----
// handle error
‚ãÆ----
const handleListen = async (socketServer: MosSocketServer) =>
‚ãÆ----
// All sockets are open and listening at this point
‚ãÆ----
/** */
private _registerIncomingClient(client: SocketDescription)
‚ãÆ----
// messageParser.debug = this._debug
‚ãÆ----
// Handle incoming data
‚ãÆ----
// handles socket listeners
client.socket.on('close', (/*hadError: boolean*/) => {
‚ãÆ----
const handleMessage = async (parsed: ParsedMosMessage, _messageString: string) =>
‚ãÆ----
const sendReply = (message: MosModel.MosMessage) =>
‚ãÆ----
// No MOS-device found in the register
// Register a new mosDevice to use for this connection:
‚ãÆ----
// Setup a "primary" connection back to the mos-device, so that we can automatically
// send commands to it through the mosDevice
‚ãÆ----
// Try to add the main mos message key to the error:
‚ãÆ----
// Something went wrong
‚ãÆ----
// Internal/parsing error
‚ãÆ----
// Log error:
‚ãÆ----
// reply with NACK:
// TODO: implement ACK
// https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS_Protocol_Version_2.8.5_Final.htm#mosAck
‚ãÆ----
sendReply(msg) // TODO: Need tests
‚ãÆ----
// No MOS-device found in the register
‚ãÆ----
// We can't handle the message, reply with a NACK:
‚ãÆ----
sendReply(msg) // TODO: Need tests
‚ãÆ----
// Register this socket:
‚ãÆ----
/** Close socket and clean up */
private _disposeIncomingSocket(socketID: string)
/** Get new unique id */
static get nextSocketID(): string
private debugTrace(...strs: any[])
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
private _scheduleCheckProfileValidness(orgStack: Error): void
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
/**
	 * Checks that all callbacks have been set up properly, according to which MOS-profile have been set in the options.
	 * throws if something's wrong
	 */
private _checkProfileValidness(orgStack: Error): void
‚ãÆ----
const fixError = (message: string) =>
‚ãÆ----
// Change the stack of the error, so that it points to the original call to the MosDevice:

================
File: packages/connector/src/MosDevice.ts
================
import { Socket } from 'net'
import { NCSServerConnection } from './connection/NCSServerConnection'
‚ãÆ----
import {
	IMOSObject,
	IMOSRunningOrder,
	IMOSRunningOrderBase,
	IMOSRunningOrderStatus,
	IMOSStoryStatus,
	IMOSItemStatus,
	IMOSROReadyToAir,
	IMOSStoryAction,
	IMOSItem,
	IMOSROAction,
	IMOSROStory,
	IMOSItemAction,
	IMOSROFullStory,
	IMOSROAck,
	IMOSAckStatus,
	IMOSObjectStatus,
	IMOSObjectList,
	IMOSRequestObjectList,
	IMOSListSearchableSchema,
	IMOSAck,
	MosItemReplaceOptions,
	IMOSExternalMetaData,
	IMOSListMachInfo,
	IMOSDefaultActiveX,
	IMOSString128,
	IMOSTime,
	getMosTypes,
	MosTypes,
	AnyXMLObject,
	AnyXMLValueSingular,
	IMOSObjectAirStatus,
} from '@mos-connection/model'
import { MosModel, MosReplyError } from '@mos-connection/helper'
import { IConnectionConfig, IMOSConnectionStatus, IMOSDevice } from './api'
import { PROFILE_VALIDNESS_CHECK_WAIT_TIME, has, safeStringify } from './lib'
import { ParsedMosMessage } from './connection/mosMessageParser'
import { XMLMosListSearchableSchema, XMLMosObjectList, isXMLObject } from '@mos-connection/helper/dist/mosModel'
‚ãÆ----
export class MosDevice implements IMOSDevice
‚ãÆ----
// private _host: string
‚ãÆ----
} // Use same names as IProfiles?
‚ãÆ----
/** If set, will do more checks that mos-protocol is properly implemented */
‚ãÆ----
// Callbacks for Profile 0:
‚ãÆ----
// Callbacks for Profile 1:
‚ãÆ----
// Callbacks for Profile 2:
‚ãÆ----
// Callbacks for Profile 3:
‚ãÆ----
// Callbacks for Profile 4:
‚ãÆ----
constructor(
		idPrimary: string,
		idSecondary: string | null,
		connectionConfig: IConnectionConfig,
		primaryConnection: NCSServerConnection | null,
		secondaryConnection: NCSServerConnection | null,
		offSpecFailover: boolean,
		strict: boolean
)
‚ãÆ----
// this._id = this.mosTypes.mosString128.create(connectionConfig.mosID).toString()
‚ãÆ----
// Add params to this in MosConnection/MosDevice
‚ãÆ----
this.hwRev = this.mosTypes.mosString128.create('0.1') // empty string returnes <hwRev/>
‚ãÆ----
this.switchConnections() // and hope no current message goes lost
‚ãÆ----
/** True if MOS-device has connection to server (can send messages) */
get hasConnection(): boolean
/** Primary ID (probably the NCS-ID) */
get idPrimary(): string
/** Secondary / Buddy ID (probably the MOS-ID) */
get idSecondary(): string | null
/** Host name (IP-address) of the primary server */
get primaryHost(): string | null
/** Name (ID) of the primary server */
get primaryId(): string | null
/** Host name (IP-address) of the secondary (buddy) server */
get secondaryHost(): string | null
/** Name (ID) of the secondary (buddy) server */
get secondaryId(): string | null
‚ãÆ----
connect(): void
async dispose(): Promise<void>
‚ãÆ----
async routeData(data: AnyXMLObject, port: MosModel.PortType): Promise<any>
‚ãÆ----
// Suppress console spam:
‚ãÆ----
// this.debugTrace('keys', Object.keys(data))
‚ãÆ----
// Route and format data:
// Profile 0: -------------------------------------------------------------------------------------------------
‚ãÆ----
// send immediate reply on the same port:
‚ãÆ----
// Profile 1: -------------------------------------------------------------------------------------------------
‚ãÆ----
// spec: Pause, when greater than zero, indicates the number of seconds to pause
// between individual mosObj messages.
// Pause of zero indicates that all objects will be sent using the mosListAll message..
// https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqAll
‚ãÆ----
// const firstObject = mosObjects.shift() as IMOSObject
// const resp = new MosObj(firstObject)
// resolve(resp)
const sendNextObject = () =>
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
// What this should contain isn't well defined in the protocol
‚ãÆ----
// Profile 2: -------------------------------------------------------------------------------------------------
// Translate deprecated messages into the functionally equivalent roElementActions:
‚ãÆ----
// This is equivalent to inserting a story at the end of the running order
‚ãÆ----
// From documentation:
// **Note**: If the second <storyID> tag is blank move the story to the bottom of the Running Order.
‚ãÆ----
// The storyID is xml-converted to a string if the second tag is missing.
// The spec says that there must be two storyID tags, so we'll throw an error here:
‚ãÆ----
// Non strict mode: This is technically out of spec, but it's a common mistake, so we'll handle it like so:
‚ãÆ----
storyID: roStorySwap.storyID, // an array
‚ãÆ----
// element_target: {
// 	storyID: roStoryDelete.storyID[1],
// },
‚ãÆ----
// From documentation:
// Validation: Duplicate storyIDs are not permitted with in the storyID list.
// This prevents the move from being ambiguous; if two IDs are the same, it is unclear
// where in the playlist the story with duplicate ID must be placed.
‚ãÆ----
// Technically a no-op:
‚ãÆ----
// Handling of edge-case:
// If there is only a single storyId, we assume that the single mentioned story should be moved to the end of the playlist
// (ie that there is supposed to be a second, blank storyId that was just omitted by the sender)
‚ãÆ----
// An additional validation checking the length of items can be added
‚ãÆ----
// RO not found
‚ãÆ----
resp.Stories = [] // dont return these (?)
‚ãÆ----
// Profile 3: -------------------------------------------------------------------------------------------------
‚ãÆ----
// Profile 4: -------------------------------------------------------------------------------------------------
‚ãÆ----
// TODO: Use reject if function dont exists? Put Nack in ondata
‚ãÆ----
// Unsupported messages: --------------------------------------------------------------------------------------
‚ãÆ----
ID: this.mosTypes.mosString128.create('0'), // TODO: Depends on type of message, needs logic
‚ãÆ----
// ============================================================================================================
// ==========================   Profile 0   ===================================================================
// ============================================================================================================
async requestMachineInfo(): Promise<IMOSListMachInfo>
‚ãÆ----
onRequestMachineInfo(cb: () => Promise<IMOSListMachInfo>): void
‚ãÆ----
onConnectionChange(cb: (connectionStatus: IMOSConnectionStatus) => void): void
‚ãÆ----
getConnectionStatus(): IMOSConnectionStatus
‚ãÆ----
// Deprecated methods:
/** @deprecated getMachineInfo is deprecated, use requestMachineInfo instead */
async getMachineInfo(): Promise<IMOSListMachInfo>
/** @deprecated onGetMachineInfo is deprecated, use onRequestMachineInfo instead */
onGetMachineInfo(cb: () => Promise<IMOSListMachInfo>): void
‚ãÆ----
// ============================================================================================================
// ==========================   Profile 1   ===================================================================
// ============================================================================================================
async sendMOSObject(obj: IMOSObject): Promise<IMOSAck>
‚ãÆ----
onRequestMOSObject(cb: (objId: string) => Promise<IMOSObject | null>): void
‚ãÆ----
async sendRequestMOSObject(objID: IMOSString128): Promise<IMOSObject>
‚ãÆ----
onRequestAllMOSObjects(cb: () => Promise<Array<IMOSObject>>): void
onMOSObjects(cb: (objs: IMOSObject[]) => Promise<IMOSAck>): void
‚ãÆ----
async sendRequestAllMOSObjects(pause = 0): Promise<IMOSAck>
‚ãÆ----
// Then we'll be sent mosListAll or mosObj messages separately,
// handled in the callback in this.onMOSObjects(cb)
‚ãÆ----
/**
	 * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosListAll
	 */
private async _sendAllMOSObjects(objs: IMOSObject[]): Promise<IMOSAck>
‚ãÆ----
/**
	 * @deprecated getMOSObject is deprecated, use sendRequestMOSObject instead
	 */
async getMOSObject(objId: IMOSString128): Promise<IMOSObject>
/** @deprecated getAllMOSObjects is deprecated, use sendRequestAllMOSObjects instead */
async getAllMOSObjects(): Promise<IMOSAck>
‚ãÆ----
// ============================================================================================================
// ==========================   Profile 2   ===================================================================
// ============================================================================================================
onCreateRunningOrder(cb: (ro: IMOSRunningOrder) => Promise<IMOSROAck>): void
async sendCreateRunningOrder(ro: IMOSRunningOrder): Promise<IMOSROAck>
‚ãÆ----
onReplaceRunningOrder(cb: (ro: IMOSRunningOrder) => Promise<IMOSROAck>): void
async sendReplaceRunningOrder(ro: IMOSRunningOrder): Promise<IMOSROAck>
‚ãÆ----
onDeleteRunningOrder(cb: (runningOrderId: IMOSString128) => Promise<IMOSROAck>): void
async sendDeleteRunningOrder(runningOrderId: IMOSString128): Promise<IMOSROAck>
‚ãÆ----
onRequestRunningOrder(cb: (runningOrderId: IMOSString128) => Promise<IMOSRunningOrder | null>): void
‚ãÆ----
async sendRequestRunningOrder(runningOrderId: IMOSString128): Promise<IMOSRunningOrder | null>
/**
	 * @deprecated getRunningOrder is deprecated, use sendRequestRunningOrder instead
	 */
async getRunningOrder(runningOrderId: IMOSString128): Promise<IMOSRunningOrder | null>
‚ãÆ----
onMetadataReplace(cb: (metadata: IMOSRunningOrderBase) => Promise<IMOSROAck>): void
async sendMetadataReplace(metadata: IMOSRunningOrderBase): Promise<IMOSROAck>
‚ãÆ----
onRunningOrderStatus(cb: (status: IMOSRunningOrderStatus) => Promise<IMOSROAck>): void
‚ãÆ----
onStoryStatus(cb: (status: IMOSStoryStatus) => Promise<IMOSROAck>): void
onItemStatus(cb: (status: IMOSItemStatus) => Promise<IMOSROAck>): void
‚ãÆ----
/** @deprecated setRunningOrderStatus is deprecated, use sendRunningOrderStatus instead */
async setRunningOrderStatus(status: IMOSRunningOrderStatus): Promise<IMOSROAck>
/** @deprecated setStoryStatus is deprecated, use sendStoryStatus instead */
async setStoryStatus(status: IMOSStoryStatus): Promise<IMOSROAck>
/** @deprecated setItemStatus is deprecated, use sendItemStatus instead */
async setItemStatus(status: IMOSItemStatus): Promise<IMOSROAck>
‚ãÆ----
async sendRunningOrderStatus(status: IMOSRunningOrderStatus): Promise<IMOSROAck>
‚ãÆ----
async sendStoryStatus(status: IMOSStoryStatus): Promise<IMOSROAck>
async sendItemStatus(status: IMOSItemStatus): Promise<IMOSROAck>
onReadyToAir(cb: (Action: IMOSROReadyToAir) => Promise<IMOSROAck>): void
async sendReadyToAir(Action: IMOSROReadyToAir): Promise<IMOSROAck>
onROInsertStories(cb: (Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>): void
async sendROInsertStories(Action: IMOSStoryAction, Stories: Array<IMOSROStory>): Promise<IMOSROAck>
onROInsertItems(cb: (Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>): void
async sendROInsertItems(Action: IMOSItemAction, Items: Array<IMOSItem>): Promise<IMOSROAck>
onROReplaceStories(cb: (Action: IMOSStoryAction, Stories: Array<IMOSROStory>) => Promise<IMOSROAck>): void
async sendROReplaceStories(Action: IMOSStoryAction, Stories: Array<IMOSROStory>): Promise<IMOSROAck>
onROReplaceItems(cb: (Action: IMOSItemAction, Items: Array<IMOSItem>) => Promise<IMOSROAck>): void
async sendROReplaceItems(Action: IMOSItemAction, Items: Array<IMOSItem>): Promise<IMOSROAck>
onROMoveStories(cb: (Action: IMOSStoryAction, Stories: Array<IMOSString128>) => Promise<IMOSROAck>): void
async sendROMoveStories(Action: IMOSStoryAction, Stories: Array<IMOSString128>): Promise<IMOSROAck>
onROMoveItems(cb: (Action: IMOSItemAction, Items: Array<IMOSString128>) => Promise<IMOSROAck>): void
async sendROMoveItems(Action: IMOSItemAction, Items: Array<IMOSString128>): Promise<IMOSROAck>
onRODeleteStories(cb: (Action: IMOSROAction, Stories: Array<IMOSString128>) => Promise<IMOSROAck>): void
async sendRODeleteStories(Action: IMOSROAction, Stories: Array<IMOSString128>): Promise<IMOSROAck>
onRODeleteItems(cb: (Action: IMOSStoryAction, Items: Array<IMOSString128>) => Promise<IMOSROAck>): void
async sendRODeleteItems(Action: IMOSStoryAction, Items: Array<IMOSString128>): Promise<IMOSROAck>
onROSwapStories(
		cb: (Action: IMOSROAction, StoryID0: IMOSString128, StoryID1: IMOSString128) => Promise<IMOSROAck>
): void
async sendROSwapStories(
		Action: IMOSROAction,
		StoryID0: IMOSString128,
		StoryID1: IMOSString128
): Promise<IMOSROAck>
onROSwapItems(
		cb: (Action: IMOSStoryAction, ItemID0: IMOSString128, ItemID1: IMOSString128) => Promise<IMOSROAck>
): void
async sendROSwapItems(Action: IMOSStoryAction, ItemID0: IMOSString128, ItemID1: IMOSString128): Promise<IMOSROAck>
‚ãÆ----
// ============================================================================================================
// ==========================   Profile 3   ===================================================================
// ============================================================================================================
onObjectCreate(cb: (object: IMOSObject) => Promise<IMOSAck>): void
‚ãÆ----
async sendObjectCreate(object: IMOSObject): Promise<IMOSAck>
‚ãÆ----
onItemReplace(cb: (roID: IMOSString128, storyID: IMOSString128, item: IMOSItem) => Promise<IMOSROAck>): void
‚ãÆ----
async sendItemReplace(options: MosItemReplaceOptions): Promise<IMOSROAck>
‚ãÆ----
onRequestSearchableSchema(cb: (username: string) => Promise<IMOSListSearchableSchema>): void
‚ãÆ----
async sendRequestSearchableSchema(username: string): Promise<IMOSListSearchableSchema>
‚ãÆ----
onRequestObjectList(cb: (objList: IMOSRequestObjectList) => Promise<IMOSObjectList>): void
‚ãÆ----
async sendRequestObjectList(reqObjList: IMOSRequestObjectList): Promise<IMOSObjectList>
‚ãÆ----
onRequestObjectActionNew(cb: (obj: IMOSObject) => Promise<IMOSAck>): void
async sendRequestObjectActionNew(obj: IMOSObject): Promise<IMOSAck>
‚ãÆ----
onRequestObjectActionUpdate(cb: (objId: IMOSString128, obj: IMOSObject) => Promise<IMOSAck>): void
async sendRequestObjectActionUpdate(objId: IMOSString128, obj: IMOSObject): Promise<IMOSAck>
onRequestObjectActionDelete(cb: (objId: IMOSString128) => Promise<IMOSAck>): void
async sendRequestObjectActionDelete(objId: IMOSString128): Promise<IMOSAck>
‚ãÆ----
// Deprecated methods:
/** @deprecated onMosObjCreate is deprecated, use onObjectCreate instead */
onMosObjCreate(cb: (object: IMOSObject) => Promise<IMOSAck>): void
/** @deprecated mosObjCreate is deprecated, use sendObjectCreate instead */
async mosObjCreate(object: IMOSObject): Promise<IMOSAck>
/** @deprecated onMosItemReplace is deprecated, use onItemReplace instead */
onMosItemReplace(cb: (roID: IMOSString128, storyID: IMOSString128, item: IMOSItem) => Promise<IMOSROAck>): void
/** @deprecated mosItemReplace is deprecated, use sendItemReplace instead */
async mosItemReplace(options: MosItemReplaceOptions): Promise<IMOSROAck>
/** @deprecated onMosReqSearchableSchema is deprecated, use onRequestSearchableSchema instead */
onMosReqSearchableSchema(cb: (username: string) => Promise<IMOSListSearchableSchema>): void
/** @deprecated mosRequestSearchableSchema is deprecated, use sendRequestSearchableSchema instead */
async mosRequestSearchableSchema(username: string): Promise<IMOSListSearchableSchema>
/** @deprecated onMosReqObjectList is deprecated, use onRequestObjectList instead */
onMosReqObjectList(cb: (objList: IMOSRequestObjectList) => Promise<IMOSObjectList>): void
/** @deprecated mosRequestObjectList is deprecated, use sendRequestObjectList instead */
async mosRequestObjectList(reqObjList: IMOSRequestObjectList): Promise<IMOSObjectList>
/** @deprecated onMosReqObjectAction is deprecated, use onRequestObjectAction*** instead */
onMosReqObjectAction(_cb: (action: string, obj: IMOSObject) => Promise<IMOSAck>): void
‚ãÆ----
// ============================================================================================================
// ==========================   Profile 4   ===================================================================
// ============================================================================================================
onRequestAllRunningOrders(cb: () => Promise<IMOSRunningOrder[]>): void
async sendRequestAllRunningOrders(): Promise<Array<IMOSRunningOrderBase>>
onRunningOrderStory(cb: (story: IMOSROFullStory) => Promise<IMOSROAck>): void
async sendRunningOrderStory(story: IMOSROFullStory): Promise<IMOSROAck>
‚ãÆ----
// Deprecated methods:
/** @deprecated onROReqAll is deprecated, use onRequestAllRunningOrders instead */
onROReqAll(cb: () => Promise<IMOSRunningOrder[]>): void
/** @deprecated getAllRunningOrders is deprecated, use sendRequestAllRunningOrders instead */
async getAllRunningOrders(): Promise<Array<IMOSRunningOrderBase>>
/** @deprecated onROStory is deprecated, use onRunningOrderStory instead */
onROStory(cb: (story: IMOSROFullStory) => Promise<IMOSROAck>): void
/** @deprecated sendROStory is deprecated, use sendRunningOrderStory instead */
async sendROStory(story: IMOSROFullStory): Promise<IMOSROAck>
‚ãÆ----
// =============================================================================================================
// ///////////////////////////////////// End of Profile methods \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
setDebug(debug: boolean): void
/**
	 * Do a check if the profile is valid. Throws if not.
	 * Optionally called after a mosDevice has been set up to ensure that all callbacks have been set up properly.
	 */
checkProfileValidness(): void
‚ãÆ----
/** Does a check if the specified profile is set, and throws otherwise */
private checkProfile(methodName: string, profile: keyof IProfiles)
‚ãÆ----
private async executeCommand(message: MosModel.MosMessage, resend?: boolean): Promise<MosReply>
private switchConnections(): void
‚ãÆ----
// Switch:
‚ãÆ----
otherConnection = currentConnection // former current connection
‚ãÆ----
private async switchConnectionsAndExecuteCommand(message: MosModel.MosMessage): Promise<MosReply>
‚ãÆ----
// @todo: we may deadlock if primary is down for us, but up for buddy
‚ãÆ----
private _emitConnectionChange(): void
private handleParseReply<T>(fcn: (strict: boolean) => T): T
‚ãÆ----
// Try again in non-strict mode, to append a sidecar to the thrown error if possible:
‚ãÆ----
// ignore error
‚ãÆ----
private unknownReply(reply: MosReply)
private badRoAckReply(xmlRoAck: AnyXMLObject)
/** throws if there is an error */
private _ensureReply(reply: ParsedMosMessage): MosReply
private _scheduleCheckProfileValidness(orgStack: Error): void
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
/**
	 * Checks that all callbacks have been set up properly, according to which MOS-profile have been set in the options.
	 * throws if something's wrong
	 */
private _checkProfileValidness(orgStack: Error): void
‚ãÆ----
const fixError = (message: string) =>
‚ãÆ----
// Change the stack of the error, so that it points to the original call to the MosDevice:
‚ãÆ----
/** For MOS-devices: Require a callback to have been set */
const requireCallback = (profile: string, callbackName: string, method: (...args: any[]) => any) =>
‚ãÆ----
// @ts-expect-error no index signature
‚ãÆ----
/** Check: Requires that a callback has been set */
const requireMOSCallback = (profile: string, callbackName: string, method: (...args: any[]) => any) =>
/** Require another profile to have been set  */
const requireProfile = (profile: number, requiredProfile: number) =>
‚ãÆ----
// @ts-expect-error no index signature
‚ãÆ----
/* eslint-disable @typescript-eslint/unbound-method */
‚ãÆ----
// _callbackOnConnectionChange not required
‚ãÆ----
private debugTrace(...strs: any[])
‚ãÆ----
// eslint-disable-next-line no-console
‚ãÆ----
export interface IProfiles {
	profile0: boolean
	profile1: boolean
	profile2: boolean
	profile3: boolean
	profile4: boolean
	profile5: boolean
	profile6: boolean
	profile7: boolean
}
‚ãÆ----
type MosReply = ParsedMosMessage



================================================================
End of Codebase
================================================================
